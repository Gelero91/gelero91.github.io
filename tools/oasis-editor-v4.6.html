<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OASIS - √âditeur de Carte Am√©lior√© v4.1</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e293b;
            --accent-color: #dc2626;
            --success-color: #16a34a;
            --warning-color: #d97706;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --border-color: #475569;
            --grid-bg: #0f172a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 340px;
            grid-template-rows: 50px 1fr 30px;
            height: 100vh;
        }

        /* HEADER */
        .header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .header h1 {
            color: var(--primary-color);
            font-size: 18px;
            font-weight: 600;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .btn:hover:not(:disabled) {
            background: var(--primary-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.primary {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn.success {
            background: var(--success-color);
            border-color: var(--success-color);
        }

        .btn.danger {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        .btn.small {
            padding: 4px 8px;
            font-size: 11px;
        }

        /* LEFT PANEL */
        .left-panel {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .tab-btn {
            flex: 1;
            padding: 10px 8px;
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            border-right: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tab-btn:last-child {
            border-right: none;
        }

        .tab-btn.active {
            background: var(--primary-color);
            color: var(--text-primary);
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        /* Sous-onglets pour les sprites */
        .sprite-subtabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .sprite-subtab {
            flex: 1;
            padding: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-size: 12px;
        }

        .sprite-subtab.active {
            color: var(--text-primary);
            border-bottom-color: var(--primary-color);
        }

        .sprite-subcontent {
            display: none;
        }

        .sprite-subcontent.active {
            display: block;
        }

        .tool-section {
            margin-bottom: 20px;
        }

        .tool-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        .tool-grid {
            display: grid;
            gap: 5px;
        }

        .tool-item {
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            text-align: left;
        }

        .tool-item:hover {
            background: var(--primary-color);
        }
        
        .tool-item.floor-texture-1:hover,
        .tool-item.floor-texture-2:hover,
        .tool-item.floor-texture-3:hover,
        .tool-item.floor-texture-4:hover,
        .tool-item.floor-texture-5:hover,
        .tool-item.floor-texture-6:hover,
        .tool-item.floor-texture-7:hover,
        .tool-item.floor-texture-8:hover,
        .tool-item.floor-texture-9:hover,
        .tool-item.floor-texture-10:hover {
            background: var(--primary-color);
            opacity: 0.9;
        }

        .tool-item.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        /* Floor texture button styles */
        .tool-item.floor-texture-1 { background: linear-gradient(to right, #f3f4f6 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-2 { background: linear-gradient(to right, #fef3c7 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-3 { background: linear-gradient(to right, #e0e7ff 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-4 { background: linear-gradient(to right, #d1fae5 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-5 { background: linear-gradient(to right, #fce7f3 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-6 { background: linear-gradient(to right, #fed7aa 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-7 { background: linear-gradient(to right, #e9d5ff 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-8 { background: linear-gradient(to right, #ccfbf1 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-9 { background: linear-gradient(to right, #f3e8ff 20%, var(--bg-tertiary) 20%); }
        .tool-item.floor-texture-10 { background: linear-gradient(to right, #dcfce7 20%, var(--bg-tertiary) 20%); }
        
        .tool-item.floor-texture-1.active,
        .tool-item.floor-texture-2.active,
        .tool-item.floor-texture-3.active,
        .tool-item.floor-texture-4.active,
        .tool-item.floor-texture-5.active,
        .tool-item.floor-texture-6.active,
        .tool-item.floor-texture-7.active,
        .tool-item.floor-texture-8.active,
        .tool-item.floor-texture-9.active,
        .tool-item.floor-texture-10.active {
            background: var(--primary-color);
        }

        /* CENTER PANEL */
        .center-panel {
            display: flex;
            flex-direction: column;
            background: var(--grid-bg);
            overflow: hidden;
        }

        .map-controls {
            padding: 10px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .coordinates {
            margin-left: auto;
            font-size: 12px;
            color: var(--text-secondary);
            font-family: monospace;
        }

        .map-container {
            flex: 1;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }

        .grid-wrapper {
            position: relative;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(24, 20px);
            grid-template-rows: repeat(24, 20px);
            gap: 1px;
            background: var(--border-color);
            padding: 1px;
        }

        .cell {
            width: 20px;
            height: 20px;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        /* Grid coordinates */
        .coord-labels {
            position: absolute;
            pointer-events: none;
        }

        .coord-x {
            top: -20px;
            left: 1px;
            right: 1px;
            height: 15px;
            display: grid;
            grid-template-columns: repeat(24, 20px);
            gap: 1px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .coord-y {
            left: -20px;
            top: 1px;
            bottom: 1px;
            width: 15px;
            display: grid;
            grid-template-rows: repeat(24, 20px);
            gap: 1px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .coord-label {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Cell types */
        .cell-floor { background-color: #f8fafc; }
        .cell-wall-1 { background-color: #64748b; color: white; }
        .cell-wall-2 { background-color: #fbbf24; color: black; }
        .cell-wall-3 { background-color: #06b6d4; color: white; }
        .cell-wall-4 { background-color: #10b981; color: white; }
        .cell-wall-5 { background-color: #8b5cf6; color: white; }
        .cell-wall-6 { background-color: #ef4444; color: white; }
        .cell-wall-7 { background-color: #f59e0b; color: white; }
        .cell-wall-8 { background-color: #84cc16; color: white; }
        .cell-wall-9 { background-color: #ec4899; color: white; }
        
        /* Floor texture variations - subtle colors */
        .cell-floor-texture-1 { background-color: #f3f4f6; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.01 - Tr√®s l√©ger gris */
        .cell-floor-texture-2 { background-color: #fef3c7; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.02 - Tr√®s l√©ger jaune */
        .cell-floor-texture-3 { background-color: #e0e7ff; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.03 - Tr√®s l√©ger bleu */
        .cell-floor-texture-4 { background-color: #d1fae5; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.04 - Tr√®s l√©ger vert */
        .cell-floor-texture-5 { background-color: #fce7f3; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.05 - Tr√®s l√©ger rose */
        .cell-floor-texture-6 { background-color: #fed7aa; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.06 - Tr√®s l√©ger orange */
        .cell-floor-texture-7 { background-color: #e9d5ff; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.07 - Tr√®s l√©ger violet */
        .cell-floor-texture-8 { background-color: #ccfbf1; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.08 - Tr√®s l√©ger turquoise */
        .cell-floor-texture-9 { background-color: #f3e8ff; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.09 - Tr√®s l√©ger lavande */
        .cell-floor-texture-10 { background-color: #dcfce7; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05); } /* 0.10 - Tr√®s l√©ger vert menthe */

        /* Sprites overlay */
        .sprite-overlay {
            position: absolute;
            top: 1px;
            right: 1px;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            text-shadow: 0 0 2px rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        /* Couleurs sp√©cifiques par type de sprite */
        .sprite-type-0 { background: linear-gradient(135deg, #6b7280, #9ca3af); }
        .sprite-type-1 { background: linear-gradient(135deg, #78716c, #a8a29e); }
        .sprite-type-2 { background: linear-gradient(135deg, #3b82f6, #60a5fa); }
        .sprite-type-3 { background: linear-gradient(135deg, #f59e0b, #fbbf24); }
        .sprite-type-A { background: linear-gradient(135deg, #dc2626, #ef4444); }
        .sprite-type-4 { background: linear-gradient(135deg, #8b5cf6, #a78bfa); }
        .sprite-type-5 { background: linear-gradient(135deg, #10b981, #34d399); }
        .sprite-type-6 { background: linear-gradient(135deg, #d97706, #f59e0b); }
        .sprite-type-EXIT { background: linear-gradient(135deg, #059669, #10b981); }
        .sprite-type-DOOR { background: linear-gradient(135deg, #7c3aed, #8b5cf6); }

        /* Player position overlay */
        .player-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid #22c55e;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        .player-arrow {
            width: 12px;
            height: 12px;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 12px solid #22c55e;
            transform-origin: 33% 50%;
        }

        .player-arrow.nord { transform: rotate(-90deg); }
        .player-arrow.sud { transform: rotate(90deg); }
        .player-arrow.est { transform: rotate(0deg); }
        .player-arrow.ouest { transform: rotate(180deg); }

        .teleport-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid;
            pointer-events: none;
        }

        .teleport-a { 
            border-color: #22c55e; 
            background: rgba(34, 197, 94, 0.1);
        }
        
        .teleport-b { 
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px dashed #fbbf24;
            pointer-events: none;
        }

        /* Drawing preview */
        .drawing-preview {
            position: absolute;
            pointer-events: none;
            background: rgba(37, 99, 235, 0.3);
            border: 1px solid var(--primary-color);
            z-index: 5;
        }

        /* RIGHT PANEL */
        .right-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 15px;
        }

        .property-section {
            margin-bottom: 20px;
        }

        .property-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .form-control {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 3px;
            font-size: 12px;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* STATUS BAR */
        .status-bar {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 5px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-ok { background: var(--success-color); }
        .status-warning { background: var(--warning-color); }
        .status-error { background: var(--accent-color); }

        /* MODAL */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h2 {
            color: var(--text-primary);
            font-size: 16px;
        }

        .modal-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Validation */
        .validation-error {
            color: var(--accent-color);
            font-size: 11px;
            margin-top: 2px;
        }

        .field-error {
            border-color: var(--accent-color) !important;
        }

        /* Maps List */
        .map-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 5px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
        }

        .map-item:hover {
            background: var(--primary-color);
        }

        .map-item.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .map-item-info {
            font-size: 12px;
        }

        .map-item-controls {
            display: flex;
            gap: 5px;
        }

        /* Dialog system */
        .dialog-entry {
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 10px;
            background: var(--bg-tertiary);
        }

        .dialog-controls {
            display: flex;
            justify-content: space-between;
            gap: 5px;
            margin-top: 5px;
        }

        .dialog-move-buttons {
            display: flex;
            gap: 5px;
        }

        /* Teleporter tabs */
        .teleport-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .teleport-tab {
            flex: 1;
            padding: 8px;
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            position: relative;
        }

        .teleport-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--primary-color);
            background: var(--bg-secondary);
        }
        
        .teleport-tab:first-child.active {
            border-bottom-color: #22c55e;
        }
        
        .teleport-tab:last-child.active {
            border-bottom-color: #3b82f6;
        }

        /* Base sprites section */
        .base-sprites-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .base-sprites-section h4 {
            font-size: 13px;
            margin-bottom: 8px;
            color: var(--success-color);
        }

        .base-sprite-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            margin-bottom: 3px;
            background: var(--bg-secondary);
            border-radius: 3px;
            font-size: 11px;
        }

        /* Enemy config */
        .config-section {
            margin-top: 15px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .config-section h4 {
            font-size: 13px;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Shop items */
        .shop-items-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .shop-item-chip {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .shop-item-chip .remove {
            color: var(--accent-color);
            cursor: pointer;
            font-weight: bold;
        }

        /* Dialog preview */
        .dialog-preview {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .dialog-preview-entry {
            margin-bottom: 5px;
            padding: 5px;
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        .dialog-preview-face {
            font-weight: bold;
            color: var(--primary-color);
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <h1>OASIS - √âditeur de Carte Am√©lior√© v4.1</h1>
            <div class="header-controls">
                <button class="btn" onclick="showMapsManager()">Gestionnaire</button>
                <button class="btn" onclick="setPlayerPositionMode()">üìç Position Joueur</button>
                <button class="btn" id="save-btn" onclick="saveCurrentMap()">Sauvegarder</button>
                <button class="btn primary" onclick="exportCurrentMap()">Exporter JSON</button>
                <button class="btn primary" onclick="exportToMapsJS()">Exporter Maps.js</button></button>
                <button class="btn success" onclick="importFromFile()">Importer</button>
                <button class="btn success" onclick="importDungeonGenerator()">Import Dungeon Gen</button>
            </div>
        </div>

        <!-- Left Panel -->
        <div class="left-panel">
            <div class="panel-tabs">
                <button class="tab-btn active" onclick="switchTab('terrain')">Terrain</button>
                <button class="tab-btn" onclick="switchTab('sprites')">Sprites</button>
                <button class="tab-btn" onclick="switchTab('teleports')">T√©l√©porteurs</button>
            </div>
            
            <div class="tab-content" id="terrain-tab">
                <div class="tool-section">
                    <h3>Outils de Dessin</h3>
                    <div class="tool-grid">
                        <div class="tool-item active" onclick="setDrawingTool('brush')">üñåÔ∏è Pinceau</div>
                        <div class="tool-item" onclick="setDrawingTool('fill')">ü™£ Remplissage</div>
                        <div class="tool-item" onclick="setDrawingTool('rectangle')">‚¨ú Rectangle</div>
                        <div class="tool-item" onclick="setDrawingTool('line')">üìè Ligne</div>
                    </div>
                </div>
                
                <div class="tool-section">
                    <h3>√âl√©ments de Terrain</h3>
                    <div class="tool-grid">
                        <div class="tool-item terrain-0 active" onclick="selectTerrain(0)">0 - Sol (traversable)</div>
                        <div class="tool-item terrain-1" onclick="selectTerrain(1)">1 - Mur de pierre</div>
                        <div class="tool-item terrain-2" onclick="selectTerrain(2)">2 - Mur orn√©</div>
                        <div class="tool-item terrain-3" onclick="selectTerrain(3)">3 - Roche</div>
                        <div class="tool-item terrain-4" onclick="selectTerrain(4)">4 - Porte de temple</div>
                        <div class="tool-item terrain-5" onclick="selectTerrain(5)">5 - For√™t</div>
                        <div class="tool-item terrain-6" onclick="selectTerrain(6)">6 - Maison</div>
                        <div class="tool-item terrain-7" onclick="selectTerrain(7)">7 - Fen√™tre maison</div>
                        <div class="tool-item terrain-8" onclick="selectTerrain(8)">8 - Porte maison</div>
                        <div class="tool-item terrain-9" onclick="selectTerrain(9)">9 - Porte prison</div>
                    </div>
                </div>
                
                <div class="tool-section">
                    <h3>Textures du Sol</h3>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                        Les textures de sol sont appliqu√©es uniquement sur les cases traversables (0).
                        Valeurs d√©cimales de 0.01 √† 0.10.
                    </div>
                    <div class="tool-grid">
                        <div class="tool-item floor-texture-1" data-texture-value="0.01" onclick="selectFloorTexture(0.01)">üé® Gris clair (0.01)</div>
                        <div class="tool-item floor-texture-2" data-texture-value="0.02" onclick="selectFloorTexture(0.02)">üé® Jaune p√¢le (0.02)</div>
                        <div class="tool-item floor-texture-3" data-texture-value="0.03" onclick="selectFloorTexture(0.03)">üé® Bleu clair (0.03)</div>
                        <div class="tool-item floor-texture-4" data-texture-value="0.04" onclick="selectFloorTexture(0.04)">üé® Vert p√¢le (0.04)</div>
                        <div class="tool-item floor-texture-5" data-texture-value="0.05" onclick="selectFloorTexture(0.05)">üé® Rose p√¢le (0.05)</div>
                        <div class="tool-item floor-texture-6" data-texture-value="0.06" onclick="selectFloorTexture(0.06)">üé® Orange p√¢le (0.06)</div>
                        <div class="tool-item floor-texture-7" data-texture-value="0.07" onclick="selectFloorTexture(0.07)">üé® Violet p√¢le (0.07)</div>
                        <div class="tool-item floor-texture-8" data-texture-value="0.08" onclick="selectFloorTexture(0.08)">üé® Turquoise (0.08)</div>
                        <div class="tool-item floor-texture-9" data-texture-value="0.09" onclick="selectFloorTexture(0.09)">üé® Lavande (0.09)</div>
                        <div class="tool-item floor-texture-10" data-texture-value="0.10" onclick="selectFloorTexture(0.10)">üé® Menthe (0.10)</div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="sprites-tab" style="display: none;">
                <!-- Sous-onglets sprites -->
                <div class="sprite-subtabs">
                    <button class="sprite-subtab active" onclick="switchSpriteSubtab('base')">Sprites de Base</button>
                    <button class="sprite-subtab" onclick="switchSpriteSubtab('editor')">√âditeur de Sprites</button>
                </div>
                
<!-- Sous-contenu Sprites de Base -->
<div class="sprite-subcontent active" id="sprite-base-content">
    <div class="base-sprites-section">
        <h4>‚ö° Sprites Pr√©-configur√©s</h4>
        
        <!--PNJ-->
        <div class="base-sprite-item">
            <span>üõ°Ô∏è Garde (dialogue)</span>
            <button class="btn small" onclick="placeBaseSprite('guard')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üè™ Marchand (shop)</span>
            <button class="btn small" onclick="placeBaseSprite('merchant')">Placer</button>
        </div>
        
        <!--ennemis-->
        <div class="base-sprite-item">
            <span>üü¢ Slime (ennemi)</span>
            <button class="btn small" onclick="placeBaseSprite('slime')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>ü¶á Chauve-souris (ennemi)</span>
            <button class="btn small" onclick="placeBaseSprite('bat')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üë∫ Gobelin (ennemi)</span>
            <button class="btn small" onclick="placeBaseSprite('gobelin')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üòà Imp (ennemi)</span>
            <button class="btn small" onclick="placeBaseSprite('imp')">Placer</button>
        </div>
        
        <!--coffres-->
        <div class="base-sprite-item">
            <span>üì¶ Coffre commun (loot A)</span>
            <button class="btn small" onclick="placeBaseSprite('chestA')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üì¶ Coffre peu commun (loot B)</span>
            <button class="btn small" onclick="placeBaseSprite('chestB')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üì¶ Coffre rare (loot C)</span>
            <button class="btn small" onclick="placeBaseSprite('chestC')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üì¶ Coffre √©pique (loot D)</span>
            <button class="btn small" onclick="placeBaseSprite('chestD')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üíé Coffre incroyable (loot E)</span>
            <button class="btn small" onclick="placeBaseSprite('chestE')">Placer</button>
        </div>

        <!--Syst√®me et d√©cors-->
        <div class="base-sprite-item">
            <span>üå¥ Palmier</span>
            <button class="btn small" onclick="placeBaseSprite('palm')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üåø Hautes herbes</span>
            <button class="btn small" onclick="placeBaseSprite('weeds')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üõ¢Ô∏è Tonneau</span>
            <button class="btn small" onclick="placeBaseSprite('barrel')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üí∞ Sac</span>
            <button class="btn small" onclick="placeBaseSprite('bag')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üèõÔ∏è Colonne</span>
            <button class="btn small" onclick="placeBaseSprite('column')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üóø Statue</span>
            <button class="btn small" onclick="placeBaseSprite('statue')">Placer</button>
        </div>
        
        <!--syst√®me-->
        <div class="base-sprite-item">
            <span>üö™ Porte</span>
            <button class="btn small" onclick="placeBaseSprite('door')">Placer</button>
        </div>
        <div class="base-sprite-item">
            <span>üèÅ Sortie niveau</span>
            <button class="btn small" onclick="placeBaseSprite('exit')">Placer</button>
        </div>
        
        <button class="btn primary" onclick="addAllBaseSprites()" style="display : none; width: 100%; margin-top: 5px;">Ajouter Tous</button>
    </div>
    
    <div class="tool-section">
        <h3>Mode d'√©dition</h3>
        <div class="tool-grid">
            <div class="tool-item" onclick="setSpriteMode('select')">üëÜ S√©lectionner</div>
            <div class="tool-item danger" onclick="setSpriteMode('erase')">üóëÔ∏è Effacer</div>
        </div>
    </div>
</div>
                
                <!-- Sous-contenu √âditeur de Sprites -->
                <div class="sprite-subcontent" id="sprite-editor-content">
                    <div class="tool-section">
                        <h3>Type de Sprite</h3>
                        <select class="form-control" id="sprite-type-select" onchange="onSpriteTypeChange()">
                            <option value="0">0 - D√©coration</option>
                            <option value="1">1 - D√©coration alt.</option>
                            <option value="2">2 - PNJ dialogue</option>
                            <option value="3">3 - Marchand</option>
                            <option value="A">A - Ennemi</option>
                            <option value="4">4 - Quest Giver</option>
                            <option value="5">5 - Quest End</option>
                            <option value="6">6 - Coffre</option>
                            <option value="EXIT">EXIT - Sortie</option>
                            <option value="DOOR">DOOR - Porte</option>
                        </select>
                    </div>
                    
                    <div class="tool-section">
                        <h3>Texture</h3>
                        <select class="form-control" id="sprite-texture-select">
                            <option value="1">1 - PNJ1</option>
                            <option value="2">2 - PNJ2</option>
                            <option value="3">3 - Garde</option>
                            <option value="4">4 - Roche</option>
                            <option value="5">5 - Tonneau</option>
                            <option value="6">6 - Buisson</option>
                            <option value="7">7 - Pancarte</option>
                            <option value="8">8 - Imp</option>
                            <option value="9">9 - Tr√©sor</option>
                            <option value="10">10 - Cadavre</option>
                            <option value="11">11 - Statue</option>
                            <option value="12">12 - Brasier</option>
                            <option value="13">13 - Herbes</option>
                            <option value="14">14 - Chauve-souris</option>
                            <option value="15">15 - Arbre</option>
                            <option value="16">16 - Colonne</option>
                            <option value="17">17 - Sac</option>
                        </select>
                    </div>
                    
                    <div class="tool-section">
                        <h3>Nom du sprite</h3>
                        <input type="text" class="form-control" id="sprite-name-input" placeholder="Nom du sprite">
                    </div>
                    
                    <!-- Configuration sp√©cifique par type -->
                    <div id="sprite-config-area"></div>
                    
                    <button class="btn primary" onclick="startPlacingCustomSprite()" style="width: 100%; margin-top: 15px;">
                        üìç Placer ce Sprite
                    </button>
                </div>
            </div>
            
            <div class="tab-content" id="teleports-tab" style="display: none;">
                <div class="tool-section">
                    <h3>Gestion T√©l√©porteurs</h3>
                    <button class="btn primary" onclick="createNewTeleporter()" style="width: 100%; margin-bottom: 10px;">Nouveau T√©l√©porteur</button>
                    <div class="form-group">
                        <select class="form-control" id="teleport-select" onchange="selectTeleporter()">
                            <option value="">Aucun t√©l√©porteur</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button class="btn danger" onclick="deleteSelectedTeleporter()" id="delete-teleport-btn" disabled>Supprimer</button>
                        <button class="btn" onclick="debugTeleporter()" style="font-size: 10px;">Debug</button>
                    </div>
                </div>
                
                <div class="tool-section" id="teleport-placement" style="display: none;">
                    <h3>Placement</h3>
                    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <button class="btn" onclick="setTeleportPlacement('A')" id="place-a-btn">Placer Point A</button>
                        <button class="btn" onclick="setTeleportPlacement('B')" id="place-b-btn">Placer Point B</button>
                    </div>
                    <button class="btn" onclick="clearTeleportPlacement()">Annuler Placement</button>
                    <div style="margin-top: 10px; font-size: 11px; color: var(--text-secondary);">
                        <div id="teleport-status-a">Point A: Non plac√©</div>
                        <div id="teleport-status-b">Point B: Non plac√©</div>
                    </div>
                </div>
                
                <div class="tool-section" id="teleport-properties" style="display: none;">
                    <h3>Propri√©t√©s du T√©l√©porteur</h3>
                    <div class="teleport-tabs">
                        <button class="teleport-tab active" onclick="switchTeleportTab('A')">Point A</button>
                        <button class="teleport-tab" onclick="switchTeleportTab('B')">Point B</button>
                    </div>
                    
                    <div id="teleport-point-A" class="teleport-point-config">
                        <h4 style="font-size: 13px; margin-bottom: 10px; color: #22c55e;">Configuration Point A</h4>
                        <div class="form-group">
                            <label>Direction</label>
                            <select class="form-control" id="teleport-a-direction">
                                <option value="nord">Nord</option>
                                <option value="est">Est</option>
                                <option value="sud">Sud</option>
                                <option value="ouest">Ouest</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="teleport-a-ceiling">
                                <label for="teleport-a-ceiling">Rendu plafond</label>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Hauteur plafond</label>
                            <input type="number" class="form-control" id="teleport-a-height" min="1" max="5" value="2">
                        </div>
                        <div class="form-group">
                            <label>Texture plafond</label>
                            <select class="form-control" id="teleport-a-ceiling-tex">
                                <option value="1">Texture 1</option>
                                <option value="2">Texture 2</option>
                                <option value="3">Texture 3</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Texture sol</label>
                            <select class="form-control" id="teleport-a-floor-tex">
                                <option value="1">Texture 1</option>
                                <option value="2">Texture 2</option>
                                <option value="3">Texture 3</option>
                                <option value="4">Texture 4</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Message</label>
                            <input type="text" class="form-control" id="teleport-a-message" placeholder="Message de transition...">
                        </div>
                    </div>
                    
                    <div id="teleport-point-B" class="teleport-point-config" style="display: none;">
                        <h4 style="font-size: 13px; margin-bottom: 10px; color: #3b82f6;">Configuration Point B</h4>
                        <div class="form-group">
                            <label>Direction</label>
                            <select class="form-control" id="teleport-b-direction">
                                <option value="nord">Nord</option>
                                <option value="est">Est</option>
                                <option value="sud">Sud</option>
                                <option value="ouest">Ouest</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="teleport-b-ceiling">
                                <label for="teleport-b-ceiling">Rendu plafond</label>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Hauteur plafond</label>
                            <input type="number" class="form-control" id="teleport-b-height" min="1" max="5" value="2">
                        </div>
                        <div class="form-group">
                            <label>Texture plafond</label>
                            <select class="form-control" id="teleport-b-ceiling-tex">
                                <option value="1">Texture 1</option>
                                <option value="2">Texture 2</option>
                                <option value="3">Texture 3</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Texture sol</label>
                            <select class="form-control" id="teleport-b-floor-tex">
                                <option value="1">Texture 1</option>
                                <option value="2">Texture 2</option>
                                <option value="3">Texture 3</option>
                                <option value="4">Texture 4</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Message</label>
                            <input type="text" class="form-control" id="teleport-b-message" placeholder="Message de transition...">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="center-panel">
            <div class="map-controls">
                <button class="btn" onclick="undoAction()" id="undo-btn" disabled>Annuler</button>
                <button class="btn" onclick="redoAction()" id="redo-btn" disabled>Refaire</button>
                <button class="btn danger" onclick="clearMap()">Vider</button>
                <div class="coordinates" id="coordinates">Position: -</div>
            </div>
            
            <div class="map-container">
                <div class="grid-wrapper">
                    <div class="coord-labels coord-x" id="coord-x"></div>
                    <div class="coord-labels coord-y" id="coord-y"></div>
                    <div class="grid" id="map-grid"></div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <div class="property-section">
                <h3>Carte Actuelle</h3>
                <div id="current-map-info">
                    <div style="font-size: 12px; color: var(--text-secondary);">Aucune carte charg√©e</div>
                </div>
            </div>
            
            <div class="property-section">
                <h3>Propri√©t√©s de la Carte</h3>
                
                <div class="form-group">
                    <label>ID de la carte</label>
                    <input type="number" class="form-control" id="map-id" value="1" min="1" onchange="updateMapProperty()">
                </div>
                
                <div class="form-group">
                    <label>Position joueur X</label>
                    <input type="number" class="form-control" id="player-x" value="12" min="1" max="22" onchange="updatePlayerPosition()">
                </div>
                
                <div class="form-group">
                    <label>Position joueur Y</label>
                    <input type="number" class="form-control" id="player-y" value="12" min="1" max="22" onchange="updatePlayerPosition()">
                </div>
                
                <div class="form-group">
                    <label>Orientation joueur</label>
                    <select class="form-control" id="player-orientation" onchange="updatePlayerPosition()">
                        <option value="nord">Nord</option>
                        <option value="est">Est</option>
                        <option value="sud">Sud</option>
                        <option value="ouest">Ouest</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="ceiling-render" onchange="updateMapProperty()">
                        <label>Rendu du plafond</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Hauteur plafond</label>
                    <input type="number" class="form-control" id="ceiling-height" value="2" min="1" max="5" onchange="updateMapProperty()">
                </div>
                
                <div class="form-group">
                    <label>Texture plafond</label>
                    <select class="form-control" id="ceiling-texture" onchange="updateMapProperty()">
                        <option value="1">Texture 1</option>
                        <option value="2">Texture 2</option>
                        <option value="3">Texture 3</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Texture sol</label>
                    <select class="form-control" id="floor-texture" onchange="updateMapProperty()">
                        <option value="1">Texture 1</option>
                        <option value="2">Texture 2</option>
                        <option value="3">Texture 3</option>
                        <option value="4">Texture 4</option>
                    </select>
                </div>
            </div>
            
            <div class="property-section">
                <h3>Validation</h3>
                <div id="validation-results">
                    <div class="status-item">
                        <div class="status-indicator status-ok"></div>
                        <span>En attente...</span>
                    </div>
                </div>
            </div>
            
            <div class="property-section">
                <h3>Export Rapide</h3>
                <button class="btn primary" onclick="copyExportToClipboard()" style="width: 100%; margin-bottom: 5px;">Copier JSON</button>
                <button class="btn primary" onclick="copyMapsJSToClipboard()" style="width: 100%; margin-bottom: 5px;">Copier Maps.js</button>
                <button class="btn" onclick="downloadMapFile()" style="width: 100%;">T√©l√©charger JSON</button>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator status-ok"></div>
                <span id="status-text">Pr√™t</span>
            </div>
            <div class="status-item">
                <span>Outil: <span id="current-tool">Pinceau - Sol</span></span>
            </div>
            <div class="status-item">
                <span>Sprites: <span id="sprite-count">0</span></span>
            </div>
            <div class="status-item">
                <span>T√©l√©porteurs: <span id="teleport-count">0</span></span>
            </div>
        </div>
    </div>

    <!-- Maps Manager Modal -->
    <div class="modal" id="maps-manager-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Gestionnaire de Cartes</h2>
            </div>
            
            <div style="margin-bottom: 15px;">
                <button class="btn primary" onclick="createNewMapInManager()">Nouvelle Carte</button>
                <button class="btn" onclick="duplicateSelectedMap()">Dupliquer</button>
                <button class="btn" onclick="importMapFile()">Importer Fichier</button>
                <button class="btn success" onclick="exportAllMaps()">Exporter Toutes JSON</button>
                <button class="btn success" onclick="exportAllMapsJS()">Exporter Maps.js</button>
            </div>
            
            <div id="maps-list" style="max-height: 300px; overflow-y: auto;">
                <!-- Maps will be listed here -->
            </div>
            
            <div class="modal-footer">
                <button class="btn" onclick="closeMapsManager()">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Sprite Properties Modal -->
    <div class="modal" id="sprite-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Propri√©t√©s du Sprite</h2>
            </div>
            
            <div class="form-group">
                <label>Nom du sprite</label>
                <input type="text" class="form-control" id="modal-sprite-name">
            </div>
            
            <div class="form-group">
                <label>Type</label>
                <select class="form-control" id="modal-sprite-type" disabled>

                    <option value="0">D√©coration</option>
                    <option value="1">D√©coration alt.</option>
                    <option value="2">PNJ dialogue</option>
                    <option value="3">Marchand</option>
                    <option value="A">Ennemi</option>
                    <option value="4">Quest Giver</option>
                    <option value="5">Quest End</option>
                    <option value="6">Coffre</option>
                    <option value="EXIT">Sortie</option>
                    <option value="DOOR">Porte</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>Texture</label>
                <select class="form-control" id="modal-sprite-texture">
                    <option value="1">1 - PNJ1</option>
                    <option value="2">2 - PNJ2</option>
                    <option value="3">3 - Garde</option>
                    <option value="4">4 - Roche</option>
                    <option value="5">5 - Tonneau</option>
                    <option value="6">6 - Buisson</option>
                    <option value="7">7 - Pancarte</option>
                    <option value="8">8 - Imp</option>
                    <option value="9">9 - Tr√©sor</option>
                    <option value="10">10 - Cadavre</option>
                    <option value="11">11 - Statue</option>
                    <option value="12">12 - Brasier</option>
                    <option value="13">13 - Herbes</option>
                    <option value="14">14 - Chauve-souris</option>
                    <option value="15">15 - Arbre</option>
                    <option value="16">16 - Colonne</option>
                    <option value="17">17 - Sac</option>
                </select>
            </div>
            
            <div id="enemy-props" style="display: none;">
                <h4 style="font-size: 14px; margin: 15px 0 10px 0;">Configuration Ennemi</h4>
                <div class="form-group">
                    <label>Points de vie</label>
                    <input type="number" class="form-control" id="modal-sprite-hp" value="2" min="1">
                </div>
                <div class="form-group">
                    <label>D√©g√¢ts</label>
                    <input type="number" class="form-control" id="modal-sprite-damage" value="1" min="1">
                </div>
                <div class="form-group">
                    <label>Classe de loot (0-5)</label>
                    <select class="form-control" id="modal-sprite-lootclass">
                        <option value="0">0 - Pas de loot</option>
                        <option value="1">1 - Tr√®s faible</option>
                        <option value="2">2 - Faible</option>
                        <option value="3">3 - Moyen</option>
                        <option value="4">4 - Fort</option>
                        <option value="5">5 - Tr√®s fort</option>
                    </select>
                </div>
            </div>
            
            <div id="chest-props" style="display: none;">
                <h4 style="font-size: 14px; margin: 15px 0 10px 0;">Configuration Coffre</h4>
                <div class="form-group">
                    <label>Classe de loot (0-5)</label>
                    <select class="form-control" id="modal-chest-lootclass">
                        <option value="0">0 - Pas de loot</option>
                        <option value="1">1 - Tr√®s faible</option>
                        <option value="2">2 - Faible</option>
                        <option value="3">3 - Moyen</option>
                        <option value="4">4 - Fort</option>
                        <option value="5">5 - Tr√®s fort</option>
                    </select>
                </div>
            </div>
            
            <div id="npc-props" style="display: none;">
                <h4 style="font-size: 14px; margin: 15px 0 10px 0;">Dialogues</h4>
                <div id="dialog-container"></div>
                <button class="btn small" onclick="addDialog()">Ajouter Dialogue</button>
                
                <div class="dialog-preview" id="dialog-preview" style="display: none;">
                    <h5 style="font-size: 12px; margin-bottom: 5px;">Aper√ßu :</h5>
                    <div id="dialog-preview-content"></div>
                </div>
            </div>
            
            <div id="shop-props" style="display: none;">
                <h4 style="font-size: 14px; margin: 15px 0 10px 0;">Boutique</h4>
                <div class="form-group">
                    <label>Items en vente</label>
                    <select class="form-control" id="modal-shop-item-select">
                        <option value="">-- Ajouter un item --</option>
                        <option value="1">1 - Shortsword</option>
                        <option value="2">2 - Cape</option>
                        <option value="3">3 - Magic sword</option>
                        <option value="4">4 - Tunic</option>
                        <option value="5">5 - Club</option>
                        <option value="6">6 - Staff</option>
                        <option value="7">7 - Armor</option>
                        <option value="8">8 - Dagger</option>
                    </select>
                    <div class="shop-items-list" id="shop-items-list"></div>
                </div>
                
                <h4 style="font-size: 14px; margin: 15px 0 10px 0;">Dialogues marchand</h4>
                <div id="merchant-dialog-container"></div>
                <button class="btn small" onclick="addMerchantDialog()">Ajouter Dialogue</button>
            </div>
            
            <div class="modal-footer">
                <button class="btn" onclick="closeSpriteModal()">Annuler</button>
                <button class="btn primary" onclick="saveSpriteProperties()">Sauvegarder</button>
            </div>
        </div>
    </div>

    <input type="file" id="import-file-input" style="display: none;" accept=".json" onchange="handleFileImport(event)">


<script>
        // Sprites de base pr√©-configur√©s
        // XYZ

// Sprites : Structure et fonctionnement

            // Types de sprites avec comportements sp√©cifiques :
            // 0 = D√©coration sans interaction (non bloquant)
            // 1 = D√©coration alternative (bloquant)
            // 2 = PNJ avec dialogues
            // 3 = Marchand (boutique avec items)
            // 4 = Quest giver (donneur de qu√™tes - non impl√©ment√©)
            // 5 = Quest end (fin de qu√™te/interaction sp√©ciale)
            // 6 = Coffre au tr√©sor (avec loot)
            // 10 = Sprites d√©coratifs multiples (g√©n√®re 2 sprites herbe al√©atoires)
            // "A" = Ennemi (combat, IA, loot)
            // "DOOR" = Porte int√©rieur/ext√©rieur (t√©l√©portation 2 cases)
            // "EXIT" = Sortie vers carte suivante
            
            // Structure des donn√©es sprites : [ID, x, y, type, texture, face, name, dialogue, items, hp, dmg, lootClass]
            // ID : Identifiant unique (0 r√©serv√© pour type 10 et sprite de combat)
            // x, y : Position en coordonn√©es de grille
            // type : Type de comportement (voir ci-dessus)
            // texture : ID de texture (1-23) :
            //   1=PNJ1, 2=PNJ2, 3=Garde, 4=Roche, 5=Tonneau, 6=Buisson, 7=Pancarte,
            //   8=Slime, 9=Tr√©sor, 10=Cadavre, 11=Statue, 12=Brasier, 13=Herbes,
            //   14=Gobelin, 15=Arbre, 16=Colonne, 17=Sac, 18=Sac (var),
            //   19=Animation slash, 20=Animation spark, 21=Coffre ouvert, 
            //   22=Chauve-souris, 23=liannes vivantes
            // face : Face pour dialogues (ex: "faceGuard", "facePlayer")
            // name : Nom du sprite
            // dialogue : Tableaux de dialogues [[face, nom, texte], ...]
            // items : Items vendus pour marchands [1,2,3,...]
            // hp : Points de vie (d√©faut: 4 pour ennemis)
            // dmg : D√©g√¢ts (d√©faut: 3 pour ennemis)
            // lootClass : Classe de loot (lettres a-f ou nombre direct pour item)

            // textures :
            // Textures disponibles pour les sprites

            /*
                1  = PNJ1               // voleur
                2  = garde              // garde
                3  = PNJ2               // marchant
                4  = Roche              // Roche
                5  = Tonneau            // Tonneau
                6  = Buisson            // Buisson
                7  = Pancarte           // Pancarte
                8  = Slime              // Slime
                9  = Tr√©sor             // Coffre au tr√©sor
                10 = Cadavre            // Cadavre ("dead enemy skull")
                11 = Statue             // Statue
                12 = Brasier            // Brasier
                13 = Herbes             // Herbes (weeds)
                14 = Gobelin            // Gobelin
                15 = Arbre              // Arbre
                16 = Colonne            // Colonne
                17 = Sac                // Sac
                18 = Sac (variante)     // Sac (autre version)
                19 = Animation slash    // Animation d'attaque slash
                20 = Animation spark    // Animation d'√©tincelles/magie
                21 = Coffre ouvert      // Coffre ouvert
                22 = chauve souris
                23 = liane vivante               
                */

       const BASE_SPRITES = {
    // PNJ, SHOP
    guard: {
        type: 2,
        texture: 3,  // ‚Üê Corrig√© : texture Garde au lieu de PNJ2
        name: "Garde du Temple",
        face: "faceGuard",
        dialogues: [
            ["facePlayer", "Aventurier", "Bonjour, j'aimerais vous aider."],
            ["faceGuard", "Garde du Temple", "Salut aventurier ! Nous avons besoin d'aide dans le temple, les cryptes sont envahies par des cr√©atures."],
            ["facePlayer", "Aventurier", "Merci pour l'info, je vais m'en occuper."]
        ],
        items: [],
        hp: 10,
        damage: 0,
        lootClass: 0
    },
    merchant: {
        type: 3,
        texture: 1,
        name: "Quill le Marchand",
        face: "faceMerchant",
        dialogues: [
            ["facePlayer", "Aventurier", "Salut !"],
            ["faceMerchant", "Quill le Marchand", "H√© mon pote ! Tu veux acheter quelque chose ?"],
            ["facePlayer", "Aventurier", "D'accord, peut-√™tre plus tard."]
        ],
        items: [1, 2, 3, 4, 5, 6, 7, 8],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    
    // ENNEMIS (avec lettres pour lootClass)
    slime: {
        type: 'A',
        texture: 8,  // Texture Imp pour slime
        name: "Slime",
        face: null,
        dialogues: [],
        items: [],
        hp: 4,
        damage: 2,
        lootClass: "b"  // ‚Üê 5-15 or, 10% chance item
    },
    bat: {
        type: 'A',
        texture: 22,
        name: "Chauve-souris",
        face: null,
        dialogues: [],
        items: [],
        hp: 2,
        damage: 1,
        lootClass: "b"  // ‚Üê 5-15 or, 10% chance item
    },
    gobelin: {
        type: 'A',
        texture: 14,  // Texture Imp pour gobelin
        name: "Gobelin",
        face: null,
        dialogues: [],
        items: [],
        hp: 5,
        damage: 3,
        lootClass: "c"  // ‚Üê 10-30 or, 20% chance item
    },
    imp: {
        type: 'A',
        texture: 23,
        name: "Plante Vivante",
        face: null,
        dialogues: [],
        items: [],
        hp: 3,
        damage: 6,
        lootClass: "d"  // ‚Üê 25-60 or, 30% chance item
    },

    // LOOTS - Coffres avec loot al√©atoire
    chestA: {
        type: 6,
        texture: 9,
        name: "Coffre au Tr√©sor commun",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: "b"  // ‚Üê 5-15 or, 10% chance item [1,2]
    },
    chestB: {
        type: 6,
        texture: 9,
        name: "Coffre au Tr√©sor peu commun",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: "c"  // ‚Üê 10-30 or, 20% chance item [1,2,5]
    },
    chestC: {
        type: 6,
        texture: 9,
        name: "Coffre au Tr√©sor rare",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: "d"  // ‚Üê 25-60 or, 30% chance item [1,2,3,5]
    },
    chestD: {
        type: 6,
        texture: 9,
        name: "Coffre au Tr√©sor √©pique",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: "e"  // ‚Üê 50-120 or, 50% chance item [2,3,4,5]
    },
    chestE: {
        type: 6,
        texture: 9,
        name: "Coffre au Tr√©sor incroyable",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: "f"  // ‚Üê 100-250 or, 70% chance item [3,4,5]
    },
    
    // DECORATION
    palm: {
        type: 0,  // Non bloquant
        texture: 15,  // Texture arbre
        name: "Palmier",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    weeds: {
        type: 10,  // ‚Üê Type 10 g√©n√®re 2 sprites herbe suppl√©mentaires
        texture: 13,  // Texture herbes
        name: "Hautes herbes",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    barrel: {
        type: 1,  // ‚Üê Type 1 pour tonneau bloquant
        texture: 5,  // Texture tonneau
        name: "Tonneau",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    bag: {
        type: 1,  // Non bloquant (peut marcher dessus)
        texture: 17,  // Texture sac
        name: "Sac",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    column: {
        type: 1,  // ‚Üê Type 1 pour colonne bloquante
        texture: 16,  // Texture colonne
        name: "Colonne",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    statue: {
        type: 1,  // ‚Üê Type 1 pour statue bloquante
        texture: 11,  // Texture statue
        name: "Statue",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    
    // SYSTEM
    door: {
        type: 'DOOR',
        texture: 16,  // Texture colonne utilis√©e comme porte
        name: "Porte",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    },
    exit: {
        type: 'EXIT',
        texture: 16,  // Texture colonne utilis√©e comme sortie
        name: "Sortie du Niveau",
        face: null,
        dialogues: [],
        items: [],
        hp: 1,
        damage: 0,
        lootClass: 0
    }
};// Application State
        
 // Fonction pour peupler dynamiquement la section des sprites de base
        function populateBaseSpritesSection() {
            const baseSpritesContainer = document.querySelector('.base-sprites-section');
            if (!baseSpritesContainer) return;

            // Effacer le contenu existant
            baseSpritesContainer.innerHTML = '<h4>‚ö° Sprites Pr√©-configur√©s</h4>';

            // Cat√©gories de sprites pour un meilleur regroupement
            const categories = {
                'PNJ et Shop': ['guard', 'merchant'],
                'Ennemis': ['slime', 'bat', 'gobelin', 'imp'],
                'Coffres': ['chestA', 'chestB', 'chestC', 'chestD', 'chestE'],
                'D√©coration': ['palm', 'weeds', 'barrel', 'bag', 'column', 'statue'],
                'Syst√®me': ['door', 'exit']
            };

            // Cr√©er des sections par cat√©gorie
            Object.entries(categories).forEach(([categoryName, spriteKeys]) => {
                const categorySection = document.createElement('div');
                categorySection.innerHTML = `<h5 style="margin-top: 10px; color: var(--success-color);">${categoryName}</h5>`;

                spriteKeys.forEach(spriteKey => {
                    const sprite = BASE_SPRITES[spriteKey];
                    if (!sprite) return;

                    const spriteItem = document.createElement('div');
                    spriteItem.className = 'base-sprite-item';
                    
                    // D√©terminer l'emoji ou l'ic√¥ne en fonction du type
                    let emoji = '‚ùì';
                    switch(sprite.type) {
                        case 'A': emoji = '‚öîÔ∏è'; break;
                        case 2: emoji = 'üí¨'; break;
                        case 3: emoji = 'üè™'; break;
                        case 6: emoji = 'üì¶'; break;
                        case 'EXIT': emoji = 'üö™'; break;
                        case 'DOOR': emoji = 'üîí'; break;
                        case 0: emoji = 'üåø'; break;
                        case 1: emoji = 'üß±'; break;
                    }

                    spriteItem.innerHTML = `
                        <span>${emoji} ${sprite.name}</span>
                        <button class="btn small" onclick="placeBaseSprite('${spriteKey}')">Placer</button>
                    `;

                    categorySection.appendChild(spriteItem);
                });

                baseSpritesContainer.appendChild(categorySection);
            });
        }

        // Modification de placeBaseSprite pour permettre le placement r√©p√©titif
        function placeBaseSprite(spriteKey) {
            if (!BASE_SPRITES[spriteKey]) {
                showStatus('Sprite de base non trouv√©', 'error');
                return;
            }
            
            APP_STATE.baseSpriteMode = spriteKey;
            APP_STATE.spriteMode = 'place';
            APP_STATE.customSpritePlacementMode = false; // Assurer qu'on n'est pas en mode placement personnalis√©
            showStatus(`Mode placement: ${BASE_SPRITES[spriteKey].name} (Mode r√©p√©titif)`, 'ok');
            updateToolDisplay(); // Pour montrer le mode actif
        }

        // M√©thode pour ajouter dynamiquement de nouveaux sprites de base
        function addNewBaseSprite(spriteKey, spriteConfig) {
            if (BASE_SPRITES[spriteKey]) {
                console.warn(`Un sprite avec la cl√© ${spriteKey} existe d√©j√†.`);
                return;
            }

            // Valider la configuration minimale
            const requiredFields = ['type', 'texture', 'name'];
            for (let field of requiredFields) {
                if (!spriteConfig[field]) {
                    console.error(`Le champ ${field} est obligatoire pour ajouter un sprite.`);
                    return;
                }
            }

            // D√©finir des valeurs par d√©faut
            spriteConfig = {
                face: null,
                dialogues: [],
                items: [],
                hp: 1,
                damage: 0,
                lootClass: 0,
                ...spriteConfig
            };

            // Ajouter le nouveau sprite √† BASE_SPRITES
            BASE_SPRITES[spriteKey] = spriteConfig;

            // Reg√©n√©rer la section des sprites de base
            populateBaseSpritesSection();

            // Notification
            showStatus(`Nouveau sprite "${spriteConfig.name}" ajout√©`, 'ok');
        }

        // M√©thode pour supprimer un sprite existant
        function removeBaseSprite(spriteKey) {
            if (!BASE_SPRITES[spriteKey]) {
                console.warn(`Aucun sprite trouv√© avec la cl√© ${spriteKey}.`);
                return;
            }

            // Supprimer le sprite
            const spriteName = BASE_SPRITES[spriteKey].name;
            delete BASE_SPRITES[spriteKey];

            // Reg√©n√©rer la section
            populateBaseSpritesSection();

            // Notification
            showStatus(`Sprite "${spriteName}" supprim√©`, 'warning');
        }


const APP_STATE = {
            // Current tab and tool
            currentTab: 'terrain',
            currentSpriteSubtab: 'base',
            drawingTool: 'brush',
            selectedTerrain: 0,
            selectedFloorTexture: null,
            terrainMode: 'terrain', // 'terrain' ou 'floorTexture'
            spriteMode: 'place',
            selectedSpriteType: 0,
            
            // Current map
            currentMapId: null,
            map: Array(24).fill().map(() => Array(24).fill(0)),
            sprites: [],
            teleporters: [],
            
            // All maps storage
            allMaps: new Map(),
            
            // History
            history: [],
            historyIndex: -1,
            
            // Selection and drawing
            selectedCell: null,
            selectedSprite: null,
            selectedTeleporter: null,
            teleportPlacementMode: null,
            playerPositionMode: false,
            
            // Drawing state
            isDrawing: false,
            drawStart: null,
            currentMousePos: null,
            
            // UI state
            isDirty: false,
            
            // Sprite creation
            baseSpriteMode: null,
            customSpriteConfig: null,
            customSpritePlacementMode: false
        };

        // Faces disponibles pour les dialogues
        const AVAILABLE_FACES = [
            'facePlayer', 'faceGuard', 'faceMerchant', 'faceThief', 
            'faceWizard', 'faceKing', 'faceQueen', 'faceVillager'
        ];

        // Initialize the application
        function init() {
            initializeBorders();
            createGrid();
            createCoordinateLabels();
            loadAllMaps();
            createNewMap();
            updateDisplay();
            setupEventListeners();
            validateCurrentMap();
            updateToolDisplay();
            
            // Nouveau : peupler les sprites de base
            populateBaseSpritesSection();
        }

        // Create coordinate labels
        function createCoordinateLabels() {
            const coordX = document.getElementById('coord-x');
            const coordY = document.getElementById('coord-y');
            
            coordX.innerHTML = '';
            coordY.innerHTML = '';
            
            for (let i = 0; i < 24; i++) {
                const label = document.createElement('div');
                label.className = 'coord-label';
                label.textContent = i;
                coordX.appendChild(label);
            }
            
            for (let i = 0; i < 24; i++) {
                const label = document.createElement('div');
                label.className = 'coord-label';
                label.textContent = i;
                coordY.appendChild(label);
            }
        }

        // Initialize borders
        function initializeBorders() {
            for (let y = 0; y < 24; y++) {
                for (let x = 0; x < 24; x++) {
                    if (x === 0 || x === 23 || y === 0 || y === 23) {
                        APP_STATE.map[y][x] = 1;
                    }
                }
            }
        }

        // Create the grid
        function createGrid() {
            const grid = document.getElementById('map-grid');
            grid.innerHTML = '';
            
            for (let y = 0; y < 24; y++) {
                for (let x = 0; x < 24; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    cell.addEventListener('mousedown', (e) => handleCellMouseDown(x, y, e));
                    cell.addEventListener('mouseenter', (e) => {
                        handleCellMouseEnter(x, y, e);
                        updateCoordinates(x, y);
                    });
                    cell.addEventListener('mouseup', () => handleCellMouseUp(x, y));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(x, y);
                    });
                    
                    grid.appendChild(cell);
                }
            }
        }

        // Mouse event handlers
        function handleCellMouseDown(x, y, e) {
            e.preventDefault();
            
            if (APP_STATE.playerPositionMode) {
                handlePlayerPositionClick(x, y);
                return;
            }
            
            APP_STATE.isDrawing = true;
            APP_STATE.drawStart = {x, y};
            APP_STATE.currentMousePos = {x, y};
            
            if (APP_STATE.currentTab === 'terrain') {
                if (APP_STATE.drawingTool === 'brush' || APP_STATE.drawingTool === 'fill') {
                    handleTerrainClick(x, y);
                } else if (APP_STATE.drawingTool === 'rectangle' || APP_STATE.drawingTool === 'line') {
                    updateDrawingPreview();
                }
            } else if (APP_STATE.currentTab === 'sprites') {
                handleSpriteClick(x, y);
            } else if (APP_STATE.currentTab === 'teleports') {
                handleTeleportClick(x, y);
            }
        }

        function handleCellMouseEnter(x, y, e) {
            APP_STATE.currentMousePos = {x, y};
            
            if (APP_STATE.isDrawing) {
                if (APP_STATE.currentTab === 'terrain') {
                    if (APP_STATE.drawingTool === 'brush') {
                        handleTerrainClick(x, y, false);
                    } else if (APP_STATE.drawingTool === 'rectangle' || APP_STATE.drawingTool === 'line') {
                        updateDrawingPreview();
                    }
                }
            }
        }

        function handleCellMouseUp(x, y) {
            if (APP_STATE.isDrawing && APP_STATE.currentTab === 'terrain') {
                if (APP_STATE.drawingTool === 'rectangle' && APP_STATE.drawStart) {
                    saveToHistory();
                    const value = APP_STATE.terrainMode === 'floorTexture' ? APP_STATE.selectedFloorTexture : APP_STATE.selectedTerrain;
                    drawRectangle(APP_STATE.drawStart.x, APP_STATE.drawStart.y, x, y, value);
                    markDirty();
                    updateDisplay();
                    validateCurrentMap();
                } else if (APP_STATE.drawingTool === 'line' && APP_STATE.drawStart) {
                    saveToHistory();
                    const value = APP_STATE.terrainMode === 'floorTexture' ? APP_STATE.selectedFloorTexture : APP_STATE.selectedTerrain;
                    drawLine(APP_STATE.drawStart.x, APP_STATE.drawStart.y, x, y, value);
                    markDirty();
                    updateDisplay();
                    validateCurrentMap();
                }
            }
            
            APP_STATE.isDrawing = false;
            APP_STATE.drawStart = null;
            removeDrawingPreview();
        }

        // Drawing preview for rectangle and line tools
        function updateDrawingPreview() {
            removeDrawingPreview();
            
            if (!APP_STATE.drawStart || !APP_STATE.currentMousePos) return;
            
            const preview = document.createElement('div');
            preview.className = 'drawing-preview';
            preview.id = 'drawing-preview';
            
            if (APP_STATE.drawingTool === 'rectangle') {
                const x1 = Math.min(APP_STATE.drawStart.x, APP_STATE.currentMousePos.x);
                const y1 = Math.min(APP_STATE.drawStart.y, APP_STATE.currentMousePos.y);
                const x2 = Math.max(APP_STATE.drawStart.x, APP_STATE.currentMousePos.x);
                const y2 = Math.max(APP_STATE.drawStart.y, APP_STATE.currentMousePos.y);
                
                preview.style.left = `${x1 * 21 + 1}px`;
                preview.style.top = `${y1 * 21 + 1}px`;
                preview.style.width = `${(x2 - x1 + 1) * 21 - 1}px`;
                preview.style.height = `${(y2 - y1 + 1) * 21 - 1}px`;
            } else if (APP_STATE.drawingTool === 'line') {
                // Pour la ligne, on pourrait afficher les cellules travers√©es
                // Pour l'instant, on affiche juste un rectangle entre les deux points
                const x1 = Math.min(APP_STATE.drawStart.x, APP_STATE.currentMousePos.x);
                const y1 = Math.min(APP_STATE.drawStart.y, APP_STATE.currentMousePos.y);
                const x2 = Math.max(APP_STATE.drawStart.x, APP_STATE.currentMousePos.x);
                const y2 = Math.max(APP_STATE.drawStart.y, APP_STATE.currentMousePos.y);
                
                preview.style.left = `${x1 * 21 + 1}px`;
                preview.style.top = `${y1 * 21 + 1}px`;
                preview.style.width = `${(x2 - x1 + 1) * 21 - 1}px`;
                preview.style.height = `${(y2 - y1 + 1) * 21 - 1}px`;
                preview.style.opacity = '0.5';
            }
            
            document.querySelector('.grid').appendChild(preview);
        }

        function removeDrawingPreview() {
            const preview = document.getElementById('drawing-preview');
            if (preview) preview.remove();
        }

        // Terrain handling
        function handleTerrainClick(x, y, saveHistory = true) {
            if ((x === 0 || x === 23 || y === 0 || y === 23) && (APP_STATE.selectedTerrain === 0 || APP_STATE.terrainMode === 'floorTexture')) {
                showStatus('Les bordures doivent rester des murs', 'error');
                return;
            }
            
            if (saveHistory) saveToHistory();
            
            if (APP_STATE.terrainMode === 'floorTexture') {
                // Apply floor texture only to traversable cells
                if (Math.floor(APP_STATE.map[y][x]) === 0) {
                    switch (APP_STATE.drawingTool) {
                        case 'brush':
                            APP_STATE.map[y][x] = APP_STATE.selectedFloorTexture;
                            break;
                        case 'fill':
                            floodFillTexture(x, y, APP_STATE.selectedFloorTexture);
                            break;
                    }
                } else {
                    showStatus('Les textures de sol ne peuvent √™tre appliqu√©es que sur des cases traversables', 'warning');
                    return;
                }
            } else {
                switch (APP_STATE.drawingTool) {
                    case 'brush':
                        APP_STATE.map[y][x] = APP_STATE.selectedTerrain;
                        break;
                    case 'fill':
                        floodFill(x, y, APP_STATE.selectedTerrain);
                        break;
                }
            }
            
            markDirty();
            updateDisplay();
            validateCurrentMap();
        }

        // Flood fill algorithm
        function floodFill(startX, startY, newValue) {
            const originalValue = APP_STATE.map[startY][startX];
            if (originalValue === newValue) return;
            
            const stack = [{x: startX, y: startY}];
            const visited = new Set();
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                if (x < 0 || x >= 24 || y < 0 || y >= 24) continue;
                if (APP_STATE.map[y][x] !== originalValue) continue;
                
                if ((x === 0 || x === 23 || y === 0 || y === 23) && newValue === 0) continue;
                
                APP_STATE.map[y][x] = newValue;
                
                stack.push({x: x+1, y}, {x: x-1, y}, {x, y: y+1}, {x, y: y-1});
            }
        }

        // Flood fill for floor textures
        function floodFillTexture(startX, startY, newValue) {
            const originalValue = APP_STATE.map[startY][startX];
            // Only fill if starting on a traversable cell
            if (Math.floor(originalValue) !== 0) return;
            
            const stack = [{x: startX, y: startY}];
            const visited = new Set();
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                if (x < 0 || x >= 24 || y < 0 || y >= 24) continue;
                // Only fill traversable cells with same texture
                if (Math.floor(APP_STATE.map[y][x]) !== 0) continue;
                if (APP_STATE.map[y][x] === newValue) continue;
                
                // Don't fill borders
                if (x === 0 || x === 23 || y === 0 || y === 23) continue;
                
                APP_STATE.map[y][x] = newValue;
                
                stack.push({x: x+1, y}, {x: x-1, y}, {x, y: y+1}, {x, y: y-1});
            }
        }

        // Draw rectangle
        function drawRectangle(x1, y1, x2, y2, value) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if ((x === 0 || x === 23 || y === 0 || y === 23) && (value === 0 || value < 1)) continue;
                    
                    if (APP_STATE.terrainMode === 'floorTexture') {
                        // Only apply texture to traversable cells
                        if (Math.floor(APP_STATE.map[y][x]) === 0) {
                            APP_STATE.map[y][x] = value;
                        }
                    } else {
                        APP_STATE.map[y][x] = value;
                    }
                }
            }
        }

        // Draw line
        function drawLine(x1, y1, x2, y2, value) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                if (!((x === 0 || x === 23 || y === 0 || y === 23) && (value === 0 || value < 1))) {
                    if (APP_STATE.terrainMode === 'floorTexture') {
                        // Only apply texture to traversable cells
                        if (Math.floor(APP_STATE.map[y][x]) === 0) {
                            APP_STATE.map[y][x] = value;
                        }
                    } else {
                        APP_STATE.map[y][x] = value;
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }

        // Player position mode
        function setPlayerPositionMode() {
            APP_STATE.playerPositionMode = true;
            showStatus('Cliquez sur la grille pour placer la position de d√©part du joueur', 'ok');
            updateToolDisplay();
        }

        function handlePlayerPositionClick(x, y) {
            if (x === 0 || x === 23 || y === 0 || y === 23) {
                showStatus('Le joueur ne peut pas d√©marrer sur les bordures', 'error');
                return;
            }
            
            if (Math.floor(APP_STATE.map[y][x]) !== 0) {
                showStatus('Le joueur doit d√©marrer sur une case traversable', 'error');
                return;
            }
            
            document.getElementById('player-x').value = x;
            document.getElementById('player-y').value = y;
            
            APP_STATE.playerPositionMode = false;
            updatePlayerPosition();
            showStatus(`Position du joueur d√©finie en [${y}, ${x}]`, 'ok');
            updateToolDisplay();
        }

        // Update player position display
        function updatePlayerPosition() {
            markDirty();
            updateDisplay();
            validateCurrentMap();
        }

        // Sprite subtab switching
        function switchSpriteSubtab(subtab) {
            document.querySelectorAll('.sprite-subtab').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.sprite-subcontent').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`sprite-${subtab}-content`).classList.add('active');
            
            APP_STATE.currentSpriteSubtab = subtab;
            
            if (subtab === 'base') {
                APP_STATE.spriteMode = 'place';
            }
            
            updateToolDisplay();
        }

        // Sprite type change handler
        function onSpriteTypeChange() {
            const type = document.getElementById('sprite-type-select').value;
            const configArea = document.getElementById('sprite-config-area');
            
            configArea.innerHTML = '';
            
            switch(type) {
                case 'A': // Ennemi
                    configArea.innerHTML = `
                        <div class="config-section">
                            <h4>Configuration Ennemi</h4>
                            <div class="form-group">
                                <label>Points de vie</label>
                                <input type="number" class="form-control" id="sprite-hp" value="2" min="1">
                            </div>
                            <div class="form-group">
                                <label>D√©g√¢ts</label>
                                <input type="number" class="form-control" id="sprite-damage" value="1" min="1">
                            </div>
                            <div class="form-group">
                                <label>Classe de loot</label>
                                <select class="form-control" id="sprite-lootclass">
                                    <option value="0">0 - Pas de loot</option>
                                    <option value="1">1 - Tr√®s faible (5-15 or)</option>
                                    <option value="2">2 - Faible (10-30 or)</option>
                                    <option value="3">3 - Moyen (25-60 or)</option>
                                    <option value="4">4 - Fort (50-120 or)</option>
                                    <option value="5">5 - Tr√®s fort (100-250 or)</option>
                                </select>
                            </div>
                        </div>
                    `;
                    break;
                    
                case '2': // PNJ avec dialogues
                case '4': // Quest Giver
                    configArea.innerHTML = `
                        <div class="config-section">
                            <h4>Dialogues</h4>
                            <div id="editor-dialog-container"></div>
                            <button class="btn small" onclick="addEditorDialog()">Ajouter Dialogue</button>
                            <div class="dialog-preview" id="editor-dialog-preview" style="display: none; margin-top: 10px;">
                                <h5 style="font-size: 12px; margin-bottom: 5px;">Aper√ßu :</h5>
                                <div id="editor-dialog-preview-content"></div>
                            </div>
                        </div>
                    `;
                    break;
                    
                case '3': // Marchand
                    configArea.innerHTML = `
                        <div class="config-section">
                            <h4>Configuration Marchand</h4>
                            <div class="form-group">
                                <label>Items en vente</label>
                                <select class="form-control" id="editor-shop-item-select" onchange="addEditorShopItem()">
                                    <option value="">-- Ajouter un item --</option>
                                    <option value="1">1 - Shortsword</option>
                                    <option value="2">2 - Cape</option>
                                    <option value="3">3 - Magic sword</option>
                                    <option value="4">4 - Tunic</option>
                                    <option value="5">5 - Club</option>
                                    <option value="6">6 - Staff</option>
                                    <option value="7">7 - Armor</option>
                                    <option value="8">8 - Dagger</option>
                                </select>
                                <div class="shop-items-list" id="editor-shop-items-list"></div>
                            </div>
                            <h4 style="margin-top: 15px;">Dialogues</h4>
                            <div id="editor-dialog-container"></div>
                            <button class="btn small" onclick="addEditorDialog()">Ajouter Dialogue</button>
                        </div>
                    `;
                    APP_STATE.editorShopItems = [];
                    break;
                    
                case '6': // Coffre
                    configArea.innerHTML = `
                        <div class="config-section">
                            <h4>Configuration Coffre</h4>
                            <div class="form-group">
                                <label>Classe de loot</label>
                                <select class="form-control" id="sprite-lootclass">
                                    <option value="0">0 - Pas de loot</option>
                                    <option value="1">1 - Tr√®s faible (5-15 or)</option>
                                    <option value="2">2 - Faible (10-30 or)</option>
                                    <option value="3">3 - Moyen (25-60 or)</option>
                                    <option value="4">4 - Fort (50-120 or)</option>
                                    <option value="5">5 - Tr√®s fort (100-250 or)</option>
                                </select>
                            </div>
                        </div>
                    `;
                    break;
            }
        }

        // Editor dialog functions
        function addEditorDialog() {
            const container = document.getElementById('editor-dialog-container');
            if (!container) return;
            
            const dialogDiv = document.createElement('div');
            dialogDiv.className = 'dialog-entry';
            
            dialogDiv.innerHTML = `
                <div class="form-group">
                    <label>Face</label>
                    <select class="form-control dialog-face" onchange="updateEditorDialogPreview()">
                        ${AVAILABLE_FACES.map(face => `<option value="${face}">${face}</option>`).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Nom</label>
                    <input type="text" class="form-control dialog-name" placeholder="Nom du personnage" onchange="updateEditorDialogPreview()">
                </div>
                <div class="form-group">
                    <label>Texte</label>
                    <textarea class="form-control dialog-text" rows="2" placeholder="Texte du dialogue" onchange="updateEditorDialogPreview()"></textarea>
                </div>
                <div class="dialog-controls">
                    <div class="dialog-move-buttons">
                        <button type="button" class="btn small" onclick="moveDialogUp(this)">‚Üë</button>
                        <button type="button" class="btn small" onclick="moveDialogDown(this)">‚Üì</button>
                    </div>
                    <button type="button" class="btn small danger" onclick="removeEditorDialog(this)">Supprimer</button>
                </div>
            `;
            
            container.appendChild(dialogDiv);
            updateEditorDialogPreview();
        }

        function removeEditorDialog(button) {
            button.closest('.dialog-entry').remove();
            updateEditorDialogPreview();
        }

        function moveDialogUp(button) {
            const entry = button.closest('.dialog-entry');
            const prev = entry.previousElementSibling;
            if (prev) {
                entry.parentNode.insertBefore(entry, prev);
                updateEditorDialogPreview();
            }
        }

        function moveDialogDown(button) {
            const entry = button.closest('.dialog-entry');
            const next = entry.nextElementSibling;
            if (next) {
                entry.parentNode.insertBefore(next, entry);
                updateEditorDialogPreview();
            }
        }

        function updateEditorDialogPreview() {
            const container = document.getElementById('editor-dialog-container');
            if (!container) return;
            
            const preview = document.getElementById('editor-dialog-preview');
            const previewContent = document.getElementById('editor-dialog-preview-content');
            
            if (!preview || !previewContent) return;
            
            const dialogEntries = container.querySelectorAll('.dialog-entry');
            
            if (dialogEntries.length === 0) {
                preview.style.display = 'none';
                return;
            }
            
            preview.style.display = 'block';
            previewContent.innerHTML = '';
            
            dialogEntries.forEach(entry => {
                const face = entry.querySelector('.dialog-face').value;
                const name = entry.querySelector('.dialog-name').value || 'Sans nom';
                const text = entry.querySelector('.dialog-text').value || '...';
                
                const previewEntry = document.createElement('div');
                previewEntry.className = 'dialog-preview-entry';
                previewEntry.innerHTML = `<span class="dialog-preview-face">${name}:</span> ${text}`;
                previewContent.appendChild(previewEntry);
            });
        }

        // Shop items management
        function addEditorShopItem() {
            const select = document.getElementById('editor-shop-item-select');
            const itemId = parseInt(select.value);
            
            if (!itemId || !APP_STATE.editorShopItems) return;
            
            if (APP_STATE.editorShopItems.includes(itemId)) {
                showStatus('Cet item est d√©j√† dans la liste', 'warning');
                select.value = '';
                return;
            }
            
            APP_STATE.editorShopItems.push(itemId);
            updateEditorShopItemsList();
            select.value = '';
        }

        function updateEditorShopItemsList() {
            const container = document.getElementById('editor-shop-items-list');
            if (!container) return;
            
            container.innerHTML = '';
            
            const itemNames = {
                1: "Shortsword",
                2: "Cape", 
                3: "Magic sword",
                4: "Tunic",
                5: "Club",
                6: "Staff",
                7: "Armor",
                8: "Dagger"
            };
            
            APP_STATE.editorShopItems.forEach(itemId => {
                const chip = document.createElement('div');
                chip.className = 'shop-item-chip';
                chip.innerHTML = `
                    ${itemId} - ${itemNames[itemId] || 'Item'}
                    <span class="remove" onclick="removeEditorShopItem(${itemId})">√ó</span>
                `;
                container.appendChild(chip);
            });
        }

        function removeEditorShopItem(itemId) {
            const index = APP_STATE.editorShopItems.indexOf(itemId);
            if (index > -1) {
                APP_STATE.editorShopItems.splice(index, 1);
                updateEditorShopItemsList();
            }
        }

        // Start placing custom sprite
        function startPlacingCustomSprite() {
            const type = document.getElementById('sprite-type-select').value;
            const texture = parseInt(document.getElementById('sprite-texture-select').value);
            const name = document.getElementById('sprite-name-input').value || `Sprite ${type}`;
            
            // Collecter la configuration selon le type
            const config = {
                type: type,
                texture: texture,
                name: name,
                face: null,
                dialogues: [],
                items: [],
                hp: 1,
                damage: 0,
                lootClass: 0
            };
            
            // Configuration sp√©cifique par type
            switch(type) {
                case 'A': // Ennemi
                    config.hp = parseInt(document.getElementById('sprite-hp')?.value || 2);
                    config.damage = parseInt(document.getElementById('sprite-damage')?.value || 1);
                    config.lootClass = parseInt(document.getElementById('sprite-lootclass')?.value || 0);
                    break;
                    
                case '2': // PNJ
                case '4': // Quest Giver
                    config.face = 'facePlayer';
                    config.dialogues = collectEditorDialogs();
                    break;
                    
                case '3': // Marchand
                    config.face = 'faceMerchant';
                    config.dialogues = collectEditorDialogs();
                    config.items = APP_STATE.editorShopItems || [];
                    break;
                    
                case '6': // Coffre
                    config.lootClass = parseInt(document.getElementById('sprite-lootclass')?.value || 0);
                    break;
            }
            
            APP_STATE.customSpriteConfig = config;
            APP_STATE.customSpritePlacementMode = true;
            APP_STATE.spriteMode = 'place';
            
            showStatus(`Cliquez sur la grille pour placer: ${name}`, 'ok');
            updateToolDisplay();
        }

        function collectEditorDialogs() {
            const container = document.getElementById('editor-dialog-container');
            if (!container) return [];
            
            const dialogEntries = container.querySelectorAll('.dialog-entry');
            const dialogues = [];
            
            dialogEntries.forEach(entry => {
                const face = entry.querySelector('.dialog-face').value;
                const name = entry.querySelector('.dialog-name').value;
                const text = entry.querySelector('.dialog-text').value;
                
                if (face && name && text) {
                    dialogues.push([face, name, text]);
                }
            });
            
            return dialogues;
        }

        // Sprite handling
        function handleSpriteClick(x, y) {
            if (APP_STATE.spriteMode === 'erase') {
                const spriteIndex = APP_STATE.sprites.findIndex(s => s.x === x && s.y === y);
                if (spriteIndex !== -1) {
                    saveToHistory();
                    APP_STATE.sprites.splice(spriteIndex, 1);
                    APP_STATE.selectedSprite = null;
                    markDirty();
                    updateDisplay();
                    updateCounts();
                }
            } else if (APP_STATE.spriteMode === 'select') {
                const sprite = APP_STATE.sprites.find(s => s.x === x && s.y === y);
                if (sprite) {
                    APP_STATE.selectedSprite = sprite;
                    document.getElementById('edit-sprite-btn').disabled = false;
                    showStatus(`Sprite s√©lectionn√©: ${sprite.name}`, 'ok');
                    
                    // Si on est dans l'onglet base, ouvrir automatiquement le modal
                    if (APP_STATE.currentSpriteSubtab === 'base') {
                        editSelectedSprite();
                    }
                } else {
                    APP_STATE.selectedSprite = null;
                    document.getElementById('edit-sprite-btn').disabled = true;
                }
                updateDisplay();
            } else if (APP_STATE.spriteMode === 'place') {
                saveToHistory();
                
                // Remove existing sprite at this position
                const existingIndex = APP_STATE.sprites.findIndex(s => s.x === x && s.y === y);
                if (existingIndex !== -1) {
                    APP_STATE.sprites.splice(existingIndex, 1);
                }
                
                let newSprite;

                if (APP_STATE.baseSpriteMode && BASE_SPRITES[APP_STATE.baseSpriteMode]) {
                    newSprite = createBaseSpriteAt(x, y, APP_STATE.baseSpriteMode);
                    // Ne pas r√©initialiser baseSpriteMode pour permettre le placement r√©p√©titif
                    showStatus(`${newSprite.name} plac√© (mode r√©p√©titif actif)`, 'ok');
                    
                } else if (APP_STATE.customSpritePlacementMode && APP_STATE.customSpriteConfig) {
                    newSprite = createCustomSpriteAt(x, y, APP_STATE.customSpriteConfig);
                    APP_STATE.customSpritePlacementMode = false;
                    APP_STATE.customSpriteConfig = null;
                    showStatus(`${newSprite.name} plac√©`, 'ok');
                } else {
                    newSprite = createSprite(x, y, APP_STATE.selectedSpriteType);
                }
                
                APP_STATE.sprites.push(newSprite);
                
                markDirty();
                updateDisplay();
                updateCounts();
                updateToolDisplay();
            }
        }

        // Create custom sprite at position
        function createCustomSpriteAt(x, y, config) {
            const id = Math.max(0, ...APP_STATE.sprites.map(s => s.id || 0)) + 1;
            
            return {
                id: id,
                x: x,
                y: y,
                type: config.type,
                texture: config.texture,
                name: config.name,
                face: config.face,
                dialogues: JSON.parse(JSON.stringify(config.dialogues)),
                items: [...config.items],
                hp: config.hp,
                damage: config.damage,
                lootClass: config.lootClass
            };
        }

        // Place base sprite
    function placeBaseSprite(spriteKey) {
        if (!BASE_SPRITES[spriteKey]) {
            showStatus('Sprite de base non trouv√©', 'error');
            return;
        }
        
        APP_STATE.baseSpriteMode = spriteKey;
        APP_STATE.spriteMode = 'place';
        APP_STATE.customSpritePlacementMode = false; // Assurer qu'on n'est pas en mode placement personnalis√©
        showStatus(`Mode placement: ${BASE_SPRITES[spriteKey].name} (Mode r√©p√©titif)`, 'ok');
        updateToolDisplay(); // Pour montrer le mode actif
    }

        // Add all base sprites
        function addAllBaseSprites() {
            if (confirm('Ajouter tous les sprites de base √† la carte ? (Garde, Marchand, Chauve-souris, Coffre, Sortie)')) {
                saveToHistory();
                
                let addedCount = 0;
                const positions = [
                    {x: 5, y: 5}, {x: 18, y: 5}, {x: 5, y: 18}, {x: 18, y: 18}, {x: 12, y: 12}
                ];
                
                Object.keys(BASE_SPRITES).forEach((key, index) => {
                    if (positions[index]) {
                        const pos = positions[index];
                        if (APP_STATE.map[pos.y][pos.x] === 0 && !APP_STATE.sprites.find(s => s.x === pos.x && s.y === pos.y)) {
                            const sprite = createBaseSpriteAt(pos.x, pos.y, key);
                            APP_STATE.sprites.push(sprite);
                            addedCount++;
                        }
                    }
                });
                
                markDirty();
                updateDisplay();
                updateCounts();
                showStatus(`${addedCount} sprites de base ajout√©s`, 'ok');
            }
        }

        // Create base sprite at position
        function createBaseSpriteAt(x, y, spriteKey) {
            const baseConfig = BASE_SPRITES[spriteKey];
            const id = Math.max(0, ...APP_STATE.sprites.map(s => s.id || 0)) + 1;
            
            return {
                id: id,
                x: x,
                y: y,
                type: baseConfig.type,
                texture: baseConfig.texture,
                name: baseConfig.name,
                face: baseConfig.face,
                dialogues: JSON.parse(JSON.stringify(baseConfig.dialogues)),
                items: [...baseConfig.items],
                hp: baseConfig.hp,
                damage: baseConfig.damage,
                lootClass: baseConfig.lootClass
            };
        }

        // Create sprite object
        function createSprite(x, y, type) {
            const texture = parseInt(document.getElementById('sprite-texture')?.value || 1);
            const id = Math.max(0, ...APP_STATE.sprites.map(s => s.id || 0)) + 1;
            
            const sprite = {
                id: id,
                x: x,
                y: y,
                type: type,
                texture: texture,
                name: `${getSpriteTypeName(type)} ${id}`,
                face: null,
                dialogues: [],
                items: [],
                hp: type === 'A' ? 2 : 1,
                damage: type === 'A' ? 1 : 0,
                lootClass: 0
            };
            
            return sprite;
        }

        // Get sprite type name
        function getSpriteTypeName(type) {
            const names = {
                0: 'D√©coration',
                1: 'D√©coration Alt',
                2: 'PNJ',
                3: 'Marchand',
                'A': 'Ennemi',
                4: 'Quest Giver',
                5: 'Quest End',
                6: 'Coffre',
                'EXIT': 'Sortie',
                'DOOR': 'Porte'
            };
            return names[type] || 'Sprite';
        }

        // Teleporter handling
        function handleTeleportClick(x, y) {
            if (!APP_STATE.teleportPlacementMode) {
                showStatus('S√©lectionnez un mode de placement', 'warning');
                return;
            }
            
            if (!APP_STATE.selectedTeleporter) {
                showStatus('Aucun t√©l√©porteur s√©lectionn√©', 'warning');
                return;
            }
            
            saveToHistory();
            
            const teleporter = APP_STATE.selectedTeleporter;
            const point = APP_STATE.teleportPlacementMode;
            
            if (point === 'A') {
                teleporter.pointA = { 
                    x, 
                    y, 
                    direction: 'nord',
                    ceilingRender: false,
                    ceilingHeight: 2,
                    ceilingTexture: 1,
                    floorTexture: 1,
                    message: ''
                };
                // Update form with default values
                if (document.getElementById('teleport-point-A').style.display !== 'none') {
                    loadTeleportProperties();
                }
                // Update status
                const statusA = document.getElementById('teleport-status-a');
                if (statusA) {
                    statusA.textContent = `Point A: [${y}, ${x}]`;
                }
            } else {
                teleporter.pointB = { 
                    x, 
                    y,
                    direction: 'nord',
                    ceilingRender: false,
                    ceilingHeight: 2,
                    ceilingTexture: 1,
                    floorTexture: 1,
                    message: ''
                };
                // Update form with default values
                if (document.getElementById('teleport-point-B').style.display !== 'none') {
                    loadTeleportProperties();
                }
                // Update status
                const statusB = document.getElementById('teleport-status-b');
                if (statusB) {
                    statusB.textContent = `Point B: [${y}, ${x}]`;
                }
            }
            
            markDirty();
            updateDisplay();
            showStatus(`Point ${point} plac√© en [${y}, ${x}]`, 'ok');
        }

        // Right click handler
        function handleRightClick(x, y) {
            if (APP_STATE.currentTab === 'terrain' && !(x === 0 || x === 23 || y === 0 || y === 23)) {
                saveToHistory();
                // Reset to plain floor (0) when right-clicking
                APP_STATE.map[y][x] = 0;
                markDirty();
                updateDisplay();
                validateCurrentMap();
            } else if (APP_STATE.currentTab === 'sprites') {
                const spriteIndex = APP_STATE.sprites.findIndex(s => s.x === x && s.y === y);
                if (spriteIndex !== -1) {
                    saveToHistory();
                    APP_STATE.sprites.splice(spriteIndex, 1);
                    markDirty();
                    updateDisplay();
                    updateCounts();
                }
            }
        }

        // Update coordinates display
        function updateCoordinates(x, y) {
            document.getElementById('coordinates').textContent = `Position: [${y}, ${x}]`;
        }

        // Tab switching
        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide tab content
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
            document.getElementById(`${tab}-tab`).style.display = 'block';
            
            APP_STATE.currentTab = tab;
            updateToolDisplay();
            
            // Clear selections when switching tabs
            if (tab !== 'sprites') {
                APP_STATE.selectedSprite = null;
                APP_STATE.baseSpriteMode = null;
                APP_STATE.customSpritePlacementMode = false;
                APP_STATE.customSpriteConfig = null;
            }
            if (tab !== 'teleports') {
                APP_STATE.teleportPlacementMode = null;
                updateTeleportButtons();
            }
            
            APP_STATE.playerPositionMode = false;
        }

        // Tool selection
        function setDrawingTool(tool) {
            document.querySelectorAll('#terrain-tab .tool-item').forEach(item => item.classList.remove('active'));
            event.target.classList.add('active');
            APP_STATE.drawingTool = tool;
            updateToolDisplay();
        }

        function selectTerrain(value) {
            // Clear previous selections
            document.querySelectorAll('[class*="terrain-"]').forEach(item => {
                if (item.classList.contains('tool-item')) {
                    item.classList.remove('active');
                }
            });
            document.querySelectorAll('[class*="floor-texture-"]').forEach(item => {
                if (item.classList.contains('tool-item')) {
                    item.classList.remove('active');
                }
            });
            
            APP_STATE.selectedTerrain = value;
            APP_STATE.terrainMode = 'terrain';
            APP_STATE.selectedFloorTexture = null;
            document.querySelectorAll('.terrain-' + value).forEach(item => item.classList.add('active'));
            updateToolDisplay();
        }

        function selectFloorTexture(value) {
            // Clear previous selections
            document.querySelectorAll('[class*="terrain-"]').forEach(item => {
                if (item.classList.contains('tool-item')) {
                    item.classList.remove('active');
                }
            });
            document.querySelectorAll('[class*="floor-texture-"]').forEach(item => {
                if (item.classList.contains('tool-item')) {
                    item.classList.remove('active');
                }
            });
            
            APP_STATE.selectedFloorTexture = value;
            APP_STATE.terrainMode = 'floorTexture';
            APP_STATE.selectedTerrain = 0; // Floor textures are applied to traversable cells
            
            // Convert decimal value to index (0.01 -> 1, 0.02 -> 2, etc.)
            const textureIndex = Math.round(value * 100);
            document.querySelectorAll('.floor-texture-' + textureIndex).forEach(item => item.classList.add('active'));
            updateToolDisplay();
        }

        function setSpriteMode(mode) {
            document.querySelectorAll('#sprite-base-content .tool-item').forEach(item => item.classList.remove('active'));
            event.target.classList.add('active');
            APP_STATE.spriteMode = mode;
            APP_STATE.baseSpriteMode = null;
            APP_STATE.customSpritePlacementMode = false;
            updateToolDisplay();
        }

        function selectSpriteType(type) {
            document.querySelectorAll('.sprite-' + APP_STATE.selectedSpriteType).forEach(item => item.classList.remove('active'));
            APP_STATE.selectedSpriteType = type;
            APP_STATE.baseSpriteMode = null;
            document.querySelectorAll('.sprite-' + type).forEach(item => item.classList.add('active'));
            updateToolDisplay();
        }

        // Update tool display
        function updateToolDisplay() {
            let toolText = '';
            
            if (APP_STATE.playerPositionMode) {
                toolText = 'Placement Position Joueur';
            } else {
                switch (APP_STATE.currentTab) {
                    case 'terrain':
                        if (APP_STATE.terrainMode === 'floorTexture') {
                            const floorTextureNames = {
                                0.01: 'Gris clair',
                                0.02: 'Jaune p√¢le',
                                0.03: 'Bleu clair',
                                0.04: 'Vert p√¢le',
                                0.05: 'Rose p√¢le',
                                0.06: 'Orange p√¢le',
                                0.07: 'Violet p√¢le',
                                0.08: 'Turquoise',
                                0.09: 'Lavande',
                                0.10: 'Menthe'
                            };
                            toolText = `${APP_STATE.drawingTool} - ${floorTextureNames[APP_STATE.selectedFloorTexture] || 'Texture'} (${APP_STATE.selectedFloorTexture})`;
                        } else {
                            const terrainNames = ['Sol', 'Pierre', 'Orn√©', 'Roche', 'Temple', 'For√™t', 'Maison', 'Fen√™tre', 'Porte M.', 'Prison'];
                            toolText = `${APP_STATE.drawingTool} - ${terrainNames[APP_STATE.selectedTerrain]}`;
                        }
                        break;
                    case 'sprites':
                        if (APP_STATE.currentSpriteSubtab === 'base') {
                            if (APP_STATE.baseSpriteMode) {
                                toolText = `Placer ${BASE_SPRITES[APP_STATE.baseSpriteMode].name}`;
                            } else {
                                toolText = APP_STATE.spriteMode === 'select' ? 'S√©lection sprite' : 'Effacer sprite';
                            }
                        } else {
                            if (APP_STATE.customSpritePlacementMode) {
                                toolText = `Placer ${APP_STATE.customSpriteConfig.name}`;
                            } else {
                                toolText = '√âditeur de sprites';
                            }
                        }
                        break;
                    case 'teleports':
                        toolText = APP_STATE.teleportPlacementMode ? `Placer Point ${APP_STATE.teleportPlacementMode}` : 'T√©l√©porteurs';
                        break;
                }
            }
            
            document.getElementById('current-tool').textContent = toolText;
        }

        function debugTeleporter() {
            if (!APP_STATE.selectedTeleporter) {
                console.log('Aucun t√©l√©porteur s√©lectionn√©');
                return;
            }
            
            console.log('=== DEBUG TELEPORTEUR ===');
            console.log('T√©l√©porteur s√©lectionn√©:', APP_STATE.selectedTeleporter);
            console.log('Point A:', APP_STATE.selectedTeleporter.pointA);
            console.log('Point B:', APP_STATE.selectedTeleporter.pointB);
            console.log('Tous les t√©l√©porteurs:', APP_STATE.teleporters);
            
            // Show in alert for easier viewing
            alert(`T√©l√©porteur ${APP_STATE.selectedTeleporter.id}:\n\n` +
                  `Point A: ${JSON.stringify(APP_STATE.selectedTeleporter.pointA, null, 2)}\n\n` +
                  `Point B: ${JSON.stringify(APP_STATE.selectedTeleporter.pointB, null, 2)}`);
        }

        // Update display
        function updateDisplay() {
            const cells = document.querySelectorAll('.cell');
            const playerX = parseInt(document.getElementById('player-x').value);
            const playerY = parseInt(document.getElementById('player-y').value);
            const playerOrientation = document.getElementById('player-orientation').value;
            
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const value = APP_STATE.map[y][x];
                
                // Clear previous classes and content
                cell.className = 'cell';
                cell.innerHTML = '';
                
                // Set terrain
                if (value === 0) {
                    cell.classList.add('cell-floor');
                } else if (value < 1 && value > 0) {
                    // Floor texture (decimal values)
                    cell.classList.add('cell-floor');
                    const textureIndex = Math.round(value * 100);
                    cell.classList.add(`cell-floor-texture-${textureIndex}`);
                } else {
                    // Walls (integer values >= 1)
                    cell.classList.add(`cell-wall-${Math.floor(value)}`);
                    cell.textContent = Math.floor(value);
                }
                
                // Add player position overlay
                if (x === playerX && y === playerY) {
                    const playerOverlay = document.createElement('div');
                    playerOverlay.className = 'player-overlay';
                    const arrow = document.createElement('div');
                    arrow.className = `player-arrow ${playerOrientation}`;
                    playerOverlay.appendChild(arrow);
                    cell.appendChild(playerOverlay);
                }
                
                // Add sprite overlay
                const sprite = APP_STATE.sprites.find(s => s.x === x && s.y === y);
                if (sprite) {
                    const overlay = document.createElement('div');
                    overlay.className = `sprite-overlay sprite-type-${sprite.type}`;
                    
                    let spriteText = sprite.type;
                    if (sprite.type === 'A') spriteText = '‚öî';
                    else if (sprite.type === 'EXIT') spriteText = 'üö™';
                    else if (sprite.type === 'DOOR') spriteText = 'üîÄ';
                    else if (sprite.type === 2) spriteText = 'üí¨';
                    else if (sprite.type === 3) spriteText = 'üè™';
                    else if (sprite.type === 6) spriteText = 'üì¶';
                    else if (sprite.type === 4) spriteText = '‚ùì';
                    else if (sprite.type === 5) spriteText = '‚úÖ';
                    
                    overlay.textContent = spriteText;
                    
                    if (sprite === APP_STATE.selectedSprite) {
                        overlay.style.border = '2px solid #fbbf24';
                        overlay.style.boxShadow = '0 0 8px rgba(251, 191, 36, 0.6)';
                    }
                    cell.appendChild(overlay);
                }
                
                // Add teleporter overlays
                APP_STATE.teleporters.forEach((teleporter, index) => {
                    if (teleporter.pointA && teleporter.pointA.x === x && teleporter.pointA.y === y) {
                        const overlay = document.createElement('div');
                        overlay.className = 'teleport-overlay teleport-a';
                        overlay.innerHTML = `<span style="position: absolute; top: 2px; left: 2px; font-size: 9px; font-weight: bold; color: #22c55e;">${teleporter.id}A</span>`;
                        cell.appendChild(overlay);
                    }
                    if (teleporter.pointB && teleporter.pointB.x === x && teleporter.pointB.y === y) {
                        const overlay = document.createElement('div');
                        overlay.className = 'teleport-overlay teleport-b';
                        overlay.innerHTML = `<span style="position: absolute; top: 2px; left: 2px; font-size: 9px; font-weight: bold; color: #3b82f6;">${teleporter.id}B</span>`;
                        cell.appendChild(overlay);
                    }
                });
            });
            
            updateCounts();
        }

        // Update counters
        function updateCounts() {
            document.getElementById('sprite-count').textContent = APP_STATE.sprites.length;
            document.getElementById('teleport-count').textContent = APP_STATE.teleporters.length;
        }

        // History management
        function saveToHistory() {
            APP_STATE.history = APP_STATE.history.slice(0, APP_STATE.historyIndex + 1);
            
            APP_STATE.history.push({
                map: APP_STATE.map.map(row => [...row]),
                sprites: JSON.parse(JSON.stringify(APP_STATE.sprites)),
                teleporters: JSON.parse(JSON.stringify(APP_STATE.teleporters))
            });
            
            APP_STATE.historyIndex++;
            
            if (APP_STATE.history.length > 50) {
                APP_STATE.history.shift();
                APP_STATE.historyIndex--;
            }
            
            updateHistoryButtons();
        }

        function undoAction() {
            if (APP_STATE.historyIndex <= 0) return;
            
            APP_STATE.historyIndex--;
            const state = APP_STATE.history[APP_STATE.historyIndex];
            
            APP_STATE.map = state.map.map(row => [...row]);
            APP_STATE.sprites = JSON.parse(JSON.stringify(state.sprites));
            APP_STATE.teleporters = JSON.parse(JSON.stringify(state.teleporters));
            
            markDirty();
            updateDisplay();
            updateHistoryButtons();
            validateCurrentMap();
            updateTeleportList();
        }

        function redoAction() {
            if (APP_STATE.historyIndex >= APP_STATE.history.length - 1) return;
            
            APP_STATE.historyIndex++;
            const state = APP_STATE.history[APP_STATE.historyIndex];
            
            APP_STATE.map = state.map.map(row => [...row]);
            APP_STATE.sprites = JSON.parse(JSON.stringify(state.sprites));
            APP_STATE.teleporters = JSON.parse(JSON.stringify(state.teleporters));
            
            markDirty();
            updateDisplay();
            updateHistoryButtons();
            validateCurrentMap();
            updateTeleportList();
        }

        function updateHistoryButtons() {
            document.getElementById('undo-btn').disabled = APP_STATE.historyIndex <= 0;
            document.getElementById('redo-btn').disabled = APP_STATE.historyIndex >= APP_STATE.history.length - 1;
        }

        // Map management
        function createNewMap() {
            const mapId = getNextMapId();
            const newMap = {
                mapID: mapId,
                name: `Carte ${mapId}`,
                map: Array(24).fill().map(() => Array(24).fill(0)),
                sprites: [],
                teleporters: [],
                playerStart: {
                    X: 12,
                    Y: 12,
                    Orientation: Math.PI / 2,
                    ceilingRender: false,
                    ceilingHeight: 2,
                    ceilingTexture: 1,
                    floorTexture: 3
                }
            };
            
            for (let y = 0; y < 24; y++) {
                for (let x = 0; x < 24; x++) {
                    if (x === 0 || x === 23 || y === 0 || y === 23) {
                        newMap.map[y][x] = 1;
                    }
                }
            }
            
            APP_STATE.allMaps.set(mapId, newMap);
            loadMapIntoEditor(mapId);
            saveAllMaps();
            showStatus(`Nouvelle carte cr√©√©e (ID: ${mapId})`, 'ok');
        }

        function getNextMapId() {
            if (APP_STATE.allMaps.size === 0) return 1;
            return Math.max(...APP_STATE.allMaps.keys()) + 1;
        }

        function loadMapIntoEditor(mapId) {
            const mapData = APP_STATE.allMaps.get(mapId);
            if (!mapData) return;
            
            APP_STATE.currentMapId = mapId;
            APP_STATE.map = mapData.map.map(row => [...row]);
            APP_STATE.sprites = JSON.parse(JSON.stringify(mapData.sprites || []));
            APP_STATE.teleporters = JSON.parse(JSON.stringify(mapData.teleporters || []));
            
            document.getElementById('map-id').value = mapData.mapID;
            document.getElementById('player-x').value = mapData.playerStart.X;
            document.getElementById('player-y').value = mapData.playerStart.Y;
            
            const orientation = mapData.playerStart.Orientation;
            let orientationName = 'nord';
            if (Math.abs(orientation - 0) < 0.1) orientationName = 'est';
            else if (Math.abs(orientation - Math.PI) < 0.1) orientationName = 'ouest';
            else if (Math.abs(orientation - 3 * Math.PI / 2) < 0.1) orientationName = 'sud';
            
            document.getElementById('player-orientation').value = orientationName;
            document.getElementById('ceiling-render').checked = mapData.playerStart.ceilingRender || false;
            document.getElementById('ceiling-height').value = mapData.playerStart.ceilingHeight || 2;
            document.getElementById('ceiling-texture').value = mapData.playerStart.ceilingTexture || 1;
            document.getElementById('floor-texture').value = mapData.playerStart.floorTexture || 3;
            
            APP_STATE.history = [];
            APP_STATE.historyIndex = -1;
            saveToHistory();
            
            APP_STATE.isDirty = false;
            updateDisplay();
            updateCurrentMapInfo();
            updateTeleportList();
            validateCurrentMap();
            showStatus(`Carte ${mapId} charg√©e`, 'ok');
        }

        function saveCurrentMap() {
            if (!APP_STATE.currentMapId) return;
            
            const mapData = {
                mapID: parseInt(document.getElementById('map-id').value),
                name: `Carte ${APP_STATE.currentMapId}`,
                map: APP_STATE.map.map(row => [...row]),
                sprites: JSON.parse(JSON.stringify(APP_STATE.sprites)),
                teleporters: JSON.parse(JSON.stringify(APP_STATE.teleporters)),
                playerStart: {
                    X: parseInt(document.getElementById('player-x').value),
                    Y: parseInt(document.getElementById('player-y').value),
                    Orientation: getOrientationValue(document.getElementById('player-orientation').value),
                    ceilingRender: document.getElementById('ceiling-render').checked,
                    ceilingHeight: parseInt(document.getElementById('ceiling-height').value),
                    ceilingTexture: parseInt(document.getElementById('ceiling-texture').value),
                    floorTexture: parseInt(document.getElementById('floor-texture').value)
                }
            };
            
            APP_STATE.allMaps.set(APP_STATE.currentMapId, mapData);
            saveAllMaps();
            APP_STATE.isDirty = false;
            updateCurrentMapInfo();
            showStatus('Carte sauvegard√©e', 'ok');
        }

        function getOrientationValue(orientation) {
            const orientations = {
                'nord': Math.PI / 2,
                'est': 0,
                'sud': 3 * Math.PI / 2,
                'ouest': Math.PI
            };
            return orientations[orientation] || Math.PI / 2;
        }

        function updateMapProperty() {
            markDirty();
            validateCurrentMap();
        }

        function markDirty() {
            APP_STATE.isDirty = true;
            updateCurrentMapInfo();
        }

        function updateCurrentMapInfo() {
            const info = document.getElementById('current-map-info');
            if (APP_STATE.currentMapId) {
                const dirtyIndicator = APP_STATE.isDirty ? ' *' : '';
                info.innerHTML = `
                    <div style="font-size: 14px; color: var(--text-primary);">Carte ${APP_STATE.currentMapId}${dirtyIndicator}</div>
                    <div style="font-size: 12px; color: var(--text-secondary);">
                        ${APP_STATE.sprites.length} sprites, ${APP_STATE.teleporters.length} t√©l√©porteurs
                    </div>
                `;
            } else {
                info.innerHTML = '<div style="font-size: 12px; color: var(--text-secondary);">Aucune carte charg√©e</div>';
            }
        }

        // Validation
        function validateCurrentMap() {
            const errors = [];
            
            for (let i = 0; i < 24; i++) {
                if (Math.floor(APP_STATE.map[0][i]) === 0) errors.push(`Bordure haut manquante en [0,${i}]`);
                if (Math.floor(APP_STATE.map[23][i]) === 0) errors.push(`Bordure bas manquante en [23,${i}]`);
                if (Math.floor(APP_STATE.map[i][0]) === 0) errors.push(`Bordure gauche manquante en [${i},0]`);
                if (Math.floor(APP_STATE.map[i][23]) === 0) errors.push(`Bordure droite manquante en [${i},23]`);
            }
            
            const playerX = parseInt(document.getElementById('player-x').value);
            const playerY = parseInt(document.getElementById('player-y').value);
            
            if (playerX < 1 || playerX > 22 || playerY < 1 || playerY > 22) {
                errors.push('Position joueur hors limites');
            } else if (Math.floor(APP_STATE.map[playerY][playerX]) !== 0) {
                errors.push('Position joueur sur un mur');
            }
            
            APP_STATE.teleporters.forEach((teleporter, index) => {
                if (!teleporter.pointA) errors.push(`T√©l√©porteur ${index + 1}: Point A manquant`);
                if (!teleporter.pointB) errors.push(`T√©l√©porteur ${index + 1}: Point B manquant`);
            });
            
            updateValidationDisplay(errors);
        }

        function updateValidationDisplay(errors) {
            const container = document.getElementById('validation-results');
            container.innerHTML = '';
            
            if (errors.length === 0) {
                container.innerHTML = `
                    <div class="status-item">
                        <div class="status-indicator status-ok"></div>
                        <span>Carte valide</span>
                    </div>
                `;
            } else {
                errors.slice(0, 5).forEach(error => {
                    container.innerHTML += `
                        <div class="status-item">
                            <div class="status-indicator status-error"></div>
                            <span style="font-size: 11px;">${error}</span>
                        </div>
                    `;
                });
                
                if (errors.length > 5) {
                    container.innerHTML += `
                        <div class="status-item">
                            <div class="status-indicator status-warning"></div>
                            <span style="font-size: 11px;">+${errors.length - 5} autres erreurs</span>
                        </div>
                    `;
                }
            }
        }

        // Teleporter management
        function createNewTeleporter() {
            saveToHistory();
            
            const newTeleporter = {
                id: APP_STATE.teleporters.length + 1,
                name: `T√©l√©porteur ${APP_STATE.teleporters.length + 1}`,
                pointA: null,
                pointB: null
            };
            
            APP_STATE.teleporters.push(newTeleporter);
            APP_STATE.selectedTeleporter = newTeleporter;
            
            markDirty();
            updateTeleportList();
            updateTeleportDisplay();
            showStatus('Nouveau t√©l√©porteur cr√©√©', 'ok');
        }

        function selectTeleporter() {
            const select = document.getElementById('teleport-select');
            const teleporterId = parseInt(select.value);
            
            if (teleporterId) {
                APP_STATE.selectedTeleporter = APP_STATE.teleporters.find(t => t.id === teleporterId);
                updateTeleportDisplay();
            } else {
                APP_STATE.selectedTeleporter = null;
                document.getElementById('teleport-placement').style.display = 'none';
                document.getElementById('teleport-properties').style.display = 'none';
            }
            
            updateTeleportButtons();
        }

        function deleteSelectedTeleporter() {
            if (!APP_STATE.selectedTeleporter) return;
            
            if (confirm('Supprimer ce t√©l√©porteur ?')) {
                saveToHistory();
                
                const index = APP_STATE.teleporters.indexOf(APP_STATE.selectedTeleporter);
                APP_STATE.teleporters.splice(index, 1);
                APP_STATE.selectedTeleporter = null;
                
                markDirty();
                updateTeleportList();
                updateTeleportDisplay();
                updateDisplay();
                showStatus('T√©l√©porteur supprim√©', 'ok');
            }
        }

        function updateTeleportList() {
            const select = document.getElementById('teleport-select');
            select.innerHTML = '<option value="">Aucun t√©l√©porteur</option>';
            
            APP_STATE.teleporters.forEach(teleporter => {
                const option = document.createElement('option');
                option.value = teleporter.id;
                
                // Add indicators for placed points
                let statusText = teleporter.name;
                if (teleporter.pointA && teleporter.pointB) {
                    statusText += ' ‚úì (A+B)';
                } else if (teleporter.pointA) {
                    statusText += ' (A)';
                } else if (teleporter.pointB) {
                    statusText += ' (B)';
                } else {
                    statusText += ' (vide)';
                }
                
                option.textContent = statusText;
                select.appendChild(option);
            });
            
            if (APP_STATE.selectedTeleporter) {
                select.value = APP_STATE.selectedTeleporter.id;
            }
        }

        function updateTeleportDisplay() {
            const placementSection = document.getElementById('teleport-placement');
            const propertiesSection = document.getElementById('teleport-properties');
            
            if (APP_STATE.selectedTeleporter) {
                placementSection.style.display = 'block';
                propertiesSection.style.display = 'block';
                
                // Update status display
                const teleporter = APP_STATE.selectedTeleporter;
                const statusA = document.getElementById('teleport-status-a');
                const statusB = document.getElementById('teleport-status-b');
                
                if (statusA) {
                    statusA.textContent = teleporter.pointA 
                        ? `Point A: [${teleporter.pointA.y}, ${teleporter.pointA.x}]`
                        : 'Point A: Non plac√©';
                }
                
                if (statusB) {
                    statusB.textContent = teleporter.pointB 
                        ? `Point B: [${teleporter.pointB.y}, ${teleporter.pointB.x}]`
                        : 'Point B: Non plac√©';
                }
                
                // Reset to Point A tab by default
                document.querySelectorAll('.teleport-tab').forEach(tab => tab.classList.remove('active'));
                document.querySelector('.teleport-tab').classList.add('active');
                document.getElementById('teleport-point-A').style.display = 'block';
                document.getElementById('teleport-point-B').style.display = 'none';
                
                loadTeleportProperties();
            } else {
                placementSection.style.display = 'none';
                propertiesSection.style.display = 'none';
            }
            
            updateTeleportButtons();
        }

        function updateTeleportButtons() {
            document.getElementById('delete-teleport-btn').disabled = !APP_STATE.selectedTeleporter;
            
            if (APP_STATE.teleportPlacementMode) {
                document.getElementById('place-a-btn').classList.toggle('primary', APP_STATE.teleportPlacementMode === 'A');
                document.getElementById('place-b-btn').classList.toggle('primary', APP_STATE.teleportPlacementMode === 'B');
            } else {
                document.getElementById('place-a-btn').classList.remove('primary');
                document.getElementById('place-b-btn').classList.remove('primary');
            }
        }

        function setTeleportPlacement(point) {
            APP_STATE.teleportPlacementMode = point;
            updateTeleportButtons();
            showStatus(`Mode placement Point ${point} activ√©`, 'ok');
        }

        function clearTeleportPlacement() {
            APP_STATE.teleportPlacementMode = null;
            updateTeleportButtons();
            showStatus('Mode placement d√©sactiv√©', 'ok');
        }

        function switchTeleportTab(point) {
            document.querySelectorAll('.teleport-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('teleport-point-A').style.display = point === 'A' ? 'block' : 'none';
            document.getElementById('teleport-point-B').style.display = point === 'B' ? 'block' : 'none';
            
            // Reload properties to ensure current tab shows correct values
            loadTeleportProperties();
        }

        function loadTeleportProperties() {
            if (!APP_STATE.selectedTeleporter) return;
            
            const teleporter = APP_STATE.selectedTeleporter;
            
            // Remove old event listeners first to avoid duplicates
            const fieldsA = ['teleport-a-direction', 'teleport-a-ceiling', 'teleport-a-height', 'teleport-a-ceiling-tex', 'teleport-a-floor-tex', 'teleport-a-message'];
            const fieldsB = ['teleport-b-direction', 'teleport-b-ceiling', 'teleport-b-height', 'teleport-b-ceiling-tex', 'teleport-b-floor-tex', 'teleport-b-message'];
            
            // Clear previous listeners
            fieldsA.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    elem.onchange = null;
                }
            });
            
            fieldsB.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    elem.onchange = null;
                }
            });
            
            // Load Point A properties
            if (teleporter.pointA) {
                document.getElementById('teleport-a-direction').value = teleporter.pointA.direction || 'nord';
                document.getElementById('teleport-a-ceiling').checked = teleporter.pointA.ceilingRender || false;
                document.getElementById('teleport-a-height').value = teleporter.pointA.ceilingHeight || 2;
                document.getElementById('teleport-a-ceiling-tex').value = teleporter.pointA.ceilingTexture || 1;
                document.getElementById('teleport-a-floor-tex').value = teleporter.pointA.floorTexture || 1;
                document.getElementById('teleport-a-message').value = teleporter.pointA.message || '';
            } else {
                // Reset fields if no point A
                document.getElementById('teleport-a-direction').value = 'nord';
                document.getElementById('teleport-a-ceiling').checked = false;
                document.getElementById('teleport-a-height').value = 2;
                document.getElementById('teleport-a-ceiling-tex').value = 1;
                document.getElementById('teleport-a-floor-tex').value = 1;
                document.getElementById('teleport-a-message').value = '';
            }
            
            // Load Point B properties
            if (teleporter.pointB) {
                document.getElementById('teleport-b-direction').value = teleporter.pointB.direction || 'nord';
                document.getElementById('teleport-b-ceiling').checked = teleporter.pointB.ceilingRender || false;
                document.getElementById('teleport-b-height').value = teleporter.pointB.ceilingHeight || 2;
                document.getElementById('teleport-b-ceiling-tex').value = teleporter.pointB.ceilingTexture || 1;
                document.getElementById('teleport-b-floor-tex').value = teleporter.pointB.floorTexture || 1;
                document.getElementById('teleport-b-message').value = teleporter.pointB.message || '';
            } else {
                // Reset fields if no point B
                document.getElementById('teleport-b-direction').value = 'nord';
                document.getElementById('teleport-b-ceiling').checked = false;
                document.getElementById('teleport-b-height').value = 2;
                document.getElementById('teleport-b-ceiling-tex').value = 1;
                document.getElementById('teleport-b-floor-tex').value = 1;
                document.getElementById('teleport-b-message').value = '';
            }
            
            // Add new event listeners for Point A
            fieldsA.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    elem.onchange = function() {
                        saveTeleportProperties('A');
                    };
                }
            });
            
            // Add new event listeners for Point B
            fieldsB.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    elem.onchange = function() {
                        saveTeleportProperties('B');
                    };
                }
            });
        }

        function saveTeleportProperties(point) {
            if (!APP_STATE.selectedTeleporter) return;
            
            const teleporter = APP_STATE.selectedTeleporter;
            const prefix = `teleport-${point.toLowerCase()}`;
            
            const properties = {
                direction: document.getElementById(`${prefix}-direction`).value,
                ceilingRender: document.getElementById(`${prefix}-ceiling`).checked,
                ceilingHeight: parseInt(document.getElementById(`${prefix}-height`).value),
                ceilingTexture: parseInt(document.getElementById(`${prefix}-ceiling-tex`).value),
                floorTexture: parseInt(document.getElementById(`${prefix}-floor-tex`).value),
                message: document.getElementById(`${prefix}-message`).value
            };
            
            if (point === 'A') {
                if (!teleporter.pointA) {
                    showStatus('Le point A doit √™tre plac√© avant de d√©finir ses propri√©t√©s', 'warning');
                    return;
                }
                // Preserve x,y coordinates and update other properties
                teleporter.pointA = {
                    ...teleporter.pointA,
                    ...properties
                };
            } else if (point === 'B') {
                if (!teleporter.pointB) {
                    showStatus('Le point B doit √™tre plac√© avant de d√©finir ses propri√©t√©s', 'warning');
                    return;
                }
                // Preserve x,y coordinates and update other properties
                teleporter.pointB = {
                    ...teleporter.pointB,
                    ...properties
                };
            }
            
            markDirty();
            
            // Debug log to verify values are saved correctly
            console.log(`T√©l√©porteur ${teleporter.id} - Point ${point} sauvegard√©:`, properties);
            console.log('√âtat complet du t√©l√©porteur:', {
                id: teleporter.id,
                pointA: teleporter.pointA,
                pointB: teleporter.pointB
            });
        }

        // Sprite properties modal
        function editSelectedSprite() {
            if (!APP_STATE.selectedSprite) return;
            
            const sprite = APP_STATE.selectedSprite;
            
            document.getElementById('modal-sprite-name').value = sprite.name || '';
            document.getElementById('modal-sprite-type').value = sprite.type;
            document.getElementById('modal-sprite-texture').value = sprite.texture;
            
            // Reset shop items state for modal
            APP_STATE.modalShopItems = sprite.items ? [...sprite.items] : [];
            
            // Show/hide relevant sections
            document.getElementById('enemy-props').style.display = sprite.type === 'A' ? 'block' : 'none';
            document.getElementById('chest-props').style.display = sprite.type === 6 ? 'block' : 'none';
            document.getElementById('npc-props').style.display = (sprite.type === 2 || sprite.type === 4) ? 'block' : 'none';
            document.getElementById('shop-props').style.display = sprite.type === 3 ? 'block' : 'none';
            
            if (sprite.type === 'A') {
                document.getElementById('modal-sprite-hp').value = sprite.hp || 2;
                document.getElementById('modal-sprite-damage').value = sprite.damage || 1;
                document.getElementById('modal-sprite-lootclass').value = sprite.lootClass || 0;
            }
            
            if (sprite.type === 6) {
                document.getElementById('modal-chest-lootclass').value = sprite.lootClass || 0;
            }
            
            if (sprite.type === 2 || sprite.type === 4) {
                loadDialogs('dialog-container', sprite.dialogues || []);
                updateModalDialogPreview();
            }
            
            if (sprite.type === 3) {
                updateShopItemsList();
                loadDialogs('merchant-dialog-container', sprite.dialogues || []);
            }
            
            // Setup shop item select listener
            const shopSelect = document.getElementById('modal-shop-item-select');
            if (shopSelect) {
                shopSelect.onchange = function() {
                    addShopItem();
                };
            }
            
            document.getElementById('sprite-modal').style.display = 'flex';
        }

        function loadDialogs(containerId, dialogues) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            dialogues.forEach((dialog, index) => {
                addDialogToContainer(container, dialog, index);
            });
        }

        function addDialogToContainer(container, dialog = null, index = -1) {
            const dialogDiv = document.createElement('div');
            dialogDiv.className = 'dialog-entry';
            
            dialogDiv.innerHTML = `
                <div class="form-group">
                    <label>Face</label>
                    <select class="form-control dialog-face" onchange="updateModalDialogPreview()">
                        ${AVAILABLE_FACES.map(face => `
                            <option value="${face}" ${(dialog?.[0] || 'facePlayer') === face ? 'selected' : ''}>${face}</option>
                        `).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Nom</label>
                    <input type="text" class="form-control dialog-name" value="${dialog?.[1] || ''}" placeholder="Nom du personnage" onchange="updateModalDialogPreview()">
                </div>
                <div class="form-group">
                    <label>Texte</label>
                    <textarea class="form-control dialog-text" rows="2" placeholder="Texte du dialogue" onchange="updateModalDialogPreview()">${dialog?.[2] || ''}</textarea>
                </div>
                <div class="dialog-controls">
                    <div class="dialog-move-buttons">
                        <button type="button" class="btn small" onclick="moveModalDialogUp(this)">‚Üë</button>
                        <button type="button" class="btn small" onclick="moveModalDialogDown(this)">‚Üì</button>
                    </div>
                    <button type="button" class="btn small danger" onclick="removeDialog(this)">Supprimer</button>
                </div>
            `;
            
            container.appendChild(dialogDiv);
        }

        function addDialog() {
            const container = document.getElementById('dialog-container');
            addDialogToContainer(container);
            updateModalDialogPreview();
        }

        function addMerchantDialog() {
            const container = document.getElementById('merchant-dialog-container');
            addDialogToContainer(container);
        }

        function removeDialog(button) {
            button.closest('.dialog-entry').remove();
            updateModalDialogPreview();
        }

        function moveModalDialogUp(button) {
            const entry = button.closest('.dialog-entry');
            const prev = entry.previousElementSibling;
            if (prev) {
                entry.parentNode.insertBefore(entry, prev);
                updateModalDialogPreview();
            }
        }

        function moveModalDialogDown(button) {
            const entry = button.closest('.dialog-entry');
            const next = entry.nextElementSibling;
            if (next) {
                entry.parentNode.insertBefore(next, entry);
                updateModalDialogPreview();
            }
        }

        function updateModalDialogPreview() {
            const container = document.getElementById('dialog-container');
            if (!container) return;
            
            const preview = document.getElementById('dialog-preview');
            const previewContent = document.getElementById('dialog-preview-content');
            
            if (!preview || !previewContent) return;
            
            const dialogEntries = container.querySelectorAll('.dialog-entry');
            
            if (dialogEntries.length === 0) {
                preview.style.display = 'none';
                return;
            }
            
            preview.style.display = 'block';
            previewContent.innerHTML = '';
            
            dialogEntries.forEach(entry => {
                const face = entry.querySelector('.dialog-face').value;
                const name = entry.querySelector('.dialog-name').value || 'Sans nom';
                const text = entry.querySelector('.dialog-text').value || '...';
                
                const previewEntry = document.createElement('div');
                previewEntry.className = 'dialog-preview-entry';
                previewEntry.innerHTML = `<span class="dialog-preview-face">${name}:</span> ${text}`;
                previewContent.appendChild(previewEntry);
            });
        }

        // Shop items management for modal
        function addShopItem() {
            const select = document.getElementById('modal-shop-item-select');
            const itemId = parseInt(select.value);
            
            if (!itemId) return;
            
            if (!APP_STATE.modalShopItems) {
                APP_STATE.modalShopItems = [];
            }
            
            if (APP_STATE.modalShopItems.includes(itemId)) {
                showStatus('Cet item est d√©j√† dans la liste', 'warning');
                select.value = '';
                return;
            }
            
            APP_STATE.modalShopItems.push(itemId);
            updateShopItemsList();
            select.value = '';
        }

        function updateShopItemsList() {
            const container = document.getElementById('shop-items-list');
            if (!container) return;
            
            container.innerHTML = '';
            
            const itemNames = {
                1: "Shortsword",
                2: "Cape", 
                3: "Magic sword",
                4: "Tunic",
                5: "Club",
                6: "Staff",
                7: "Armor",
                8: "Dagger"
            };
            
            if (!APP_STATE.modalShopItems) {
                APP_STATE.modalShopItems = [];
            }
            
            APP_STATE.modalShopItems.forEach(itemId => {
                const chip = document.createElement('div');
                chip.className = 'shop-item-chip';
                chip.innerHTML = `
                    ${itemId} - ${itemNames[itemId] || 'Item'}
                    <span class="remove" onclick="removeShopItem(${itemId})">√ó</span>
                `;
                container.appendChild(chip);
            });
        }

        function removeShopItem(itemId) {
            if (!APP_STATE.modalShopItems) return;
            
            const index = APP_STATE.modalShopItems.indexOf(itemId);
            if (index > -1) {
                APP_STATE.modalShopItems.splice(index, 1);
                updateShopItemsList();
            }
        }

        function saveSpriteProperties() {
            if (!APP_STATE.selectedSprite) {
                closeSpriteModal();
                return;
            }
            
            const sprite = APP_STATE.selectedSprite;
            
            sprite.name = document.getElementById('modal-sprite-name').value;
            sprite.texture = parseInt(document.getElementById('modal-sprite-texture').value);
            
            if (sprite.type === 'A') {
                sprite.hp = parseInt(document.getElementById('modal-sprite-hp').value);
                sprite.damage = parseInt(document.getElementById('modal-sprite-damage').value);
                sprite.lootClass = parseInt(document.getElementById('modal-sprite-lootclass').value);
            }
            
            if (sprite.type === 6) {
                sprite.lootClass = parseInt(document.getElementById('modal-chest-lootclass').value);
            }
            
            if (sprite.type === 2 || sprite.type === 4) {
                sprite.dialogues = collectDialogs('dialog-container');
            }
            
            if (sprite.type === 3) {
                sprite.items = APP_STATE.modalShopItems ? [...APP_STATE.modalShopItems] : [];
                sprite.dialogues = collectDialogs('merchant-dialog-container');
            }
            
            markDirty();
            updateDisplay();
            closeSpriteModal();
            showStatus('Propri√©t√©s du sprite sauvegard√©es', 'ok');
        }

        function collectDialogs(containerId) {
            const container = document.getElementById(containerId);
            const dialogEntries = container.querySelectorAll('.dialog-entry');
            const dialogues = [];
            
            dialogEntries.forEach(entry => {
                const face = entry.querySelector('.dialog-face').value;
                const name = entry.querySelector('.dialog-name').value;
                const text = entry.querySelector('.dialog-text').value;
                
                if (face && name && text) {
                    dialogues.push([face, name, text]);
                }
            });
            
            return dialogues;
        }

        function closeSpriteModal() {
            document.getElementById('sprite-modal').style.display = 'none';
            APP_STATE.modalShopItems = [];
        }

        // Maps manager
        function showMapsManager() {
            updateMapsManagerList();
            document.getElementById('maps-manager-modal').style.display = 'flex';
        }

        function closeMapsManager() {
            document.getElementById('maps-manager-modal').style.display = 'none';
        }

        function updateMapsManagerList() {
            const container = document.getElementById('maps-list');
            container.innerHTML = '';
            
            APP_STATE.allMaps.forEach((mapData, mapId) => {
                const mapItem = document.createElement('div');
                mapItem.className = 'map-item';
                if (mapId === APP_STATE.currentMapId) {
                    mapItem.classList.add('active');
                }
                
                mapItem.innerHTML = `
                    <div class="map-item-info">
                        <div style="font-weight: bold;">Carte ${mapId}</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            ${mapData.sprites?.length || 0} sprites, ${mapData.teleporters?.length || 0} t√©l√©porteurs
                        </div>
                    </div>
                    <div class="map-item-controls">
                        <button class="btn small" onclick="loadMapFromManager(${mapId})">Charger</button>
                        <button class="btn small" onclick="exportSingleMap(${mapId})">Exporter</button>
                        <button class="btn small danger" onclick="deleteMapFromManager(${mapId})">√ó</button>
                    </div>
                `;
                
                container.appendChild(mapItem);
            });
            
            if (APP_STATE.allMaps.size === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucune carte disponible</div>';
            }
        }

        function loadMapFromManager(mapId) {
            if (APP_STATE.isDirty) {
                if (!confirm('Vous avez des modifications non sauvegard√©es. Continuer ?')) {
                    return;
                }
            }
            
            loadMapIntoEditor(mapId);
            closeMapsManager();
        }

        function deleteMapFromManager(mapId) {
            if (confirm(`Supprimer d√©finitivement la carte ${mapId} ?`)) {
                APP_STATE.allMaps.delete(mapId);
                saveAllMaps();
                
                if (mapId === APP_STATE.currentMapId) {
                    if (APP_STATE.allMaps.size > 0) {
                        const firstMapId = APP_STATE.allMaps.keys().next().value;
                        loadMapIntoEditor(firstMapId);
                    } else {
                        createNewMap();
                    }
                }
                
                updateMapsManagerList();
                showStatus(`Carte ${mapId} supprim√©e`, 'ok');
            }
        }

        function createNewMapInManager() {
            createNewMap();
            updateMapsManagerList();
        }

        function duplicateSelectedMap() {
            if (!APP_STATE.currentMapId) {
                showStatus('Aucune carte s√©lectionn√©e', 'warning');
                return;
            }
            
            const originalMap = APP_STATE.allMaps.get(APP_STATE.currentMapId);
            if (!originalMap) return;
            
            const newMapId = getNextMapId();
            const duplicatedMap = JSON.parse(JSON.stringify(originalMap));
            duplicatedMap.mapID = newMapId;
            duplicatedMap.name = `Carte ${newMapId} (copie)`;
            
            APP_STATE.allMaps.set(newMapId, duplicatedMap);
            saveAllMaps();
            updateMapsManagerList();
            showStatus(`Carte dupliqu√©e (ID: ${newMapId})`, 'ok');
        }

        // Export to Maps.js format
        function exportToMapsJS() {
            // Always export ALL maps to Maps.js
            const allMapsData = [];
            
            // Save current map first
            if (APP_STATE.currentMapId) {
                saveCurrentMap();
            }
            
            // Collect all maps
            APP_STATE.allMaps.forEach((mapData, mapId) => {
                allMapsData.push(generateRaycastFormat(mapData));
            });
            
            // Sort by mapID for consistent order
            allMapsData.sort((a, b) => a.mapID - b.mapID);
            
            const mapsJSContent = generateMapsJSFormat(allMapsData);
            
            const blob = new Blob([mapsJSContent], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Maps.js';
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus(`${allMapsData.length} carte(s) export√©e(s) dans Maps.js`, 'ok');
        }

        function exportAllMapsJS() {
            // This function is now redundant with exportToMapsJS, but kept for compatibility
            exportToMapsJS();
        }

        function generateMapsJSFormat(mapsArray) {
            let jsContent = 'const maps = [\n';
            
            mapsArray.forEach((map, index) => {
                jsContent += '    {\n';
                
                // mapID
                jsContent += `      "mapID": ${map.mapID},\n`;
                
                // map array with pretty formatting
                jsContent += '      "map": [\n';
                map.map.forEach((row, rowIndex) => {
                    jsContent += '  [';
                    row.forEach((cell, cellIndex) => {
                        // Format numbers with proper decimal places
                        let cellValue = cell;
                        if (typeof cell === 'number') {
                            if (cell % 1 === 0) {
                                cellValue = cell.toString();
                            } else {
                                cellValue = cell.toFixed(2);
                            }
                        }
                        // Pad single digit values for alignment
                        if (cellValue.length === 1) cellValue = ' ' + cellValue;
                        jsContent += cellValue;
                        if (cellIndex < row.length - 1) jsContent += ', ';
                    });
                    jsContent += ']';
                    if (rowIndex < map.map.length - 1) jsContent += ',';
                    jsContent += '\n';
                });
                jsContent += '],\n';
                
                // sprites array
                jsContent += '      "sprites": [\n';
                map.sprites.forEach((sprite, spriteIndex) => {
                    jsContent += '        [\n';
                    sprite.forEach((prop, propIndex) => {
                        jsContent += '          ';
                        if (typeof prop === 'string') {
                            jsContent += `"${prop}"`;
                        } else if (prop === null) {
                            jsContent += 'null';
                        } else if (Array.isArray(prop)) {
                            jsContent += JSON.stringify(prop, null, 0);
                        } else {
                            jsContent += prop;
                        }
                        if (propIndex < sprite.length - 1) jsContent += ',';
                        jsContent += '\n';
                    });
                    jsContent += '        ]';
                    if (spriteIndex < map.sprites.length - 1) jsContent += ',';
                    jsContent += '\n';
                });
                jsContent += '      ],\n';
                
                // eventA
                jsContent += '      "eventA": ';
                jsContent += JSON.stringify(map.eventA);
                jsContent += ',\n';
                
                // eventB
                jsContent += '      "eventB": ';
                jsContent += JSON.stringify(map.eventB);
                jsContent += ',\n';
                
                // playerStart
                jsContent += '      "playerStart": {\n';
                jsContent += `        "X": ${map.playerStart.X},\n`;
                jsContent += `        "Y": ${map.playerStart.Y},\n`;
                jsContent += `        "Orientation": ${map.playerStart.Orientation},\n`;
                jsContent += `        "ceilingRender": ${map.playerStart.ceilingRender},\n`;
                jsContent += `        "ceilingHeight": ${map.playerStart.ceilingHeight},\n`;
                jsContent += `        "ceilingTexture": ${map.playerStart.ceilingTexture},\n`;
                jsContent += `        "floorTexture": ${map.playerStart.floorTexture}\n`;
                jsContent += '      }\n';
                
                jsContent += '    }';
                if (index < mapsArray.length - 1) jsContent += ',';
                jsContent += '\n';
            });
            
            jsContent += '    ];\n\n';
            
            // Add export statement for ES6 modules compatibility
            jsContent += '// Export for ES6 modules\n';
            jsContent += 'if (typeof module !== "undefined" && module.exports) {\n';
            jsContent += '    module.exports = maps;\n';
            jsContent += '}\n';
            
            return jsContent;
        }

        function copyMapsJSToClipboard() {
            // Always copy ALL maps to clipboard
            const allMapsData = [];
            
            // Save current map first
            if (APP_STATE.currentMapId) {
                saveCurrentMap();
            }
            
            // Collect all maps
            APP_STATE.allMaps.forEach((mapData, mapId) => {
                allMapsData.push(generateRaycastFormat(mapData));
            });
            
            // Sort by mapID for consistent order
            allMapsData.sort((a, b) => a.mapID - b.mapID);
            
            const mapsJSContent = generateMapsJSFormat(allMapsData);
            
            navigator.clipboard.writeText(mapsJSContent).then(() => {
                showStatus(`Maps.js avec ${allMapsData.length} carte(s) copi√© dans le presse-papier`, 'ok');
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = mapsJSContent;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus(`Maps.js avec ${allMapsData.length} carte(s) copi√© dans le presse-papier`, 'ok');
            });
        }
        function exportCurrentMap() {
            if (!APP_STATE.currentMapId) {
                showStatus('Aucune carte √† exporter', 'warning');
                return;
            }
            
            saveCurrentMap();
            const mapData = generateRaycastFormat(APP_STATE.allMaps.get(APP_STATE.currentMapId));
            
            const blob = new Blob([JSON.stringify(mapData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `oasis_map_${APP_STATE.currentMapId}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('Carte export√©e', 'ok');
        }

        function exportSingleMap(mapId) {
            const mapData = generateRaycastFormat(APP_STATE.allMaps.get(mapId));
            
            const blob = new Blob([JSON.stringify(mapData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `oasis_map_${mapId}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportAllMaps() {
            const allMapsData = [];
            
            APP_STATE.allMaps.forEach((mapData, mapId) => {
                allMapsData.push(generateRaycastFormat(mapData));
            });
            
            const exportData = {
                version: '4.0',
                maps: allMapsData,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `oasis_maps_collection.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('Collection export√©e', 'ok');
        }

        function generateRaycastFormat(mapData) {
            // Ensure decimal values are preserved in the export
            const exportMap = mapData.map.map(row => 
                row.map(cell => {
                    // Preserve decimal values for floor textures
                    if (cell > 0 && cell < 1) {
                        return Math.round(cell * 100) / 100; // Ensure 2 decimal places
                    }
                    return cell;
                })
            );
            
            const raycastSprites = mapData.sprites.map(sprite => [
                sprite.id,
                sprite.x,
                sprite.y,
                sprite.type,
                sprite.texture,
                sprite.face || null,
                sprite.name,
                sprite.dialogues || [],
                sprite.items || [],
                sprite.hp || 1,
                sprite.damage || 0,
                sprite.lootClass || 0
            ]);
            
            const eventA = [];
            const eventB = [];
            
            mapData.teleporters.forEach(teleporter => {
                if (teleporter.pointA && teleporter.pointB) {
                    eventA.push([
                        teleporter.pointA.x,
                        teleporter.pointA.y,
                        getOrientationValue(teleporter.pointA.direction),
                        teleporter.pointA.ceilingRender,
                        teleporter.pointA.ceilingTexture,
                        teleporter.pointA.ceilingHeight,
                        teleporter.pointA.floorTexture,
                        teleporter.pointA.message
                    ]);
                    
                    eventB.push([
                        teleporter.pointB.x,
                        teleporter.pointB.y,
                        getOrientationValue(teleporter.pointB.direction),
                        teleporter.pointB.ceilingRender,
                        teleporter.pointB.ceilingTexture,
                        teleporter.pointB.ceilingHeight,
                        teleporter.pointB.floorTexture,
                        teleporter.pointB.message
                    ]);
                }
            });
            
            return {
                mapID: mapData.mapID,
                map: exportMap,
                sprites: raycastSprites,
                eventA: eventA,
                eventB: eventB,
                playerStart: mapData.playerStart
            };
        }

        function copyExportToClipboard() {
            if (!APP_STATE.currentMapId) {
                showStatus('Aucune carte √† exporter', 'warning');
                return;
            }
            
            saveCurrentMap();
            const mapData = generateRaycastFormat(APP_STATE.allMaps.get(APP_STATE.currentMapId));
            const jsonString = JSON.stringify(mapData, null, 2);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                showStatus('JSON copi√© dans le presse-papier', 'ok');
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = jsonString;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('JSON copi√© dans le presse-papier', 'ok');
            });
        }

        function downloadMapFile() {
            exportCurrentMap();
        }

        function importFromFile() {
            document.getElementById('import-file-input').click();
        }

        function importMapFile() {
            document.getElementById('import-file-input').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.grid && data.metadata) {
                        importDungeonData(data);
                    } else if (data.maps) {
                        importMapsCollection(data.maps);
                    } else if (data.mapID) {
                        importSingleMap(data);
                    } else {
                        showStatus('Format de fichier non reconnu', 'error');
                    }
                } catch (error) {
                    showStatus('Erreur lors de l\'importation', 'error');
                    console.error('Import error:', error);
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }

        function importSingleMap(mapData) {
            const editorMap = {
                mapID: mapData.mapID,
                name: `Carte ${mapData.mapID}`,
                map: mapData.map,
                sprites: mapData.sprites.map(s => ({
                    id: s[0],
                    x: s[1],
                    y: s[2],
                    type: s[3],
                    texture: s[4],
                    face: s[5],
                    name: s[6] || `Sprite ${s[0]}`,
                    dialogues: s[7] || [],
                    items: s[8] || [],
                    hp: s[9] || 1,
                    damage: s[10] || 0,
                    lootClass: s[11] || 0
                })),
                teleporters: [],
                playerStart: mapData.playerStart
            };
            
            if (mapData.eventA && mapData.eventB && mapData.eventA.length === mapData.eventB.length) {
                for (let i = 0; i < mapData.eventA.length; i++) {
                    const eventA = mapData.eventA[i];
                    const eventB = mapData.eventB[i];
                    
                    editorMap.teleporters.push({
                        id: i + 1,
                        name: `T√©l√©porteur ${i + 1}`,
                        pointA: {
                            x: eventA[0],
                            y: eventA[1],
                            direction: getOrientationName(eventA[2]),
                            ceilingRender: eventA[3],
                            ceilingTexture: eventA[4],
                            ceilingHeight: eventA[5],
                            floorTexture: eventA[6],
                            message: eventA[7]
                        },
                        pointB: {
                            x: eventB[0],
                            y: eventB[1],
                            direction: getOrientationName(eventB[2]),
                            ceilingRender: eventB[3],
                            ceilingTexture: eventB[4],
                            ceilingHeight: eventB[5],
                            floorTexture: eventB[6],
                            message: eventB[7]
                        }
                    });
                }
            }
            
            APP_STATE.allMaps.set(mapData.mapID, editorMap);
            saveAllMaps();
            loadMapIntoEditor(mapData.mapID);
            showStatus(`Carte ${mapData.mapID} import√©e`, 'ok');
        }

        function importMapsCollection(maps) {
            let importedCount = 0;
            
            maps.forEach(mapData => {
                try {
                    importSingleMap(mapData);
                    importedCount++;
                } catch (error) {
                    console.error('Error importing map:', mapData.mapID, error);
                }
            });
            
            showStatus(`${importedCount} cartes import√©es`, 'ok');
        }

        function getOrientationName(value) {
            const orientations = {
                [Math.PI / 2]: 'nord',
                [0]: 'est',
                [3 * Math.PI / 2]: 'sud',
                [Math.PI]: 'ouest'
            };
            
            let closestOrientation = 'nord';
            let minDiff = Math.PI;
            
            Object.entries(orientations).forEach(([radians, name]) => {
                const diff = Math.abs(parseFloat(radians) - value);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestOrientation = name;
                }
            });
            
            return closestOrientation;
        }

        // Import from dungeon generator
        function importDungeonGenerator() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        importDungeonData(data);
                    } catch (error) {
                        showStatus('Erreur lors de l\'importation du donjon', 'error');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function importDungeonData(dungeonData) {
            if (!dungeonData.grid && !dungeonData.metadata) {
                showStatus('Format de donjon non reconnu', 'error');
                return;
            }
            
            const mapId = getNextMapId();
            const newMap = {
                mapID: mapId,
                name: `Donjon G√©n√©r√© ${mapId}`,
                map: [],
                sprites: [],
                teleporters: [],
                playerStart: {
                    X: 12,
                    Y: 12,
                    Orientation: Math.PI / 2,
                    ceilingRender: false,
                    ceilingHeight: 2,
                    ceilingTexture: 1,
                    floorTexture: 3
                }
            };
            
            const dungeonGrid = dungeonData.grid;
            const gridSize = dungeonGrid.length;
            
            newMap.map = Array(24).fill().map(() => Array(24).fill(1));
            
            const ratio = gridSize / 24;
            
            for (let y = 0; y < 24; y++) {
                for (let x = 0; x < 24; x++) {
                    if (x === 0 || x === 23 || y === 0 || y === 23) {
                        newMap.map[y][x] = 1;
                        continue;
                    }
                    
                    const sourceX = Math.floor(x * ratio);
                    const sourceY = Math.floor(y * ratio);
                    
                    if (sourceX < gridSize && sourceY < gridSize) {
                        newMap.map[y][x] = dungeonGrid[sourceY][sourceX] === 0 ? 0 : 1;
                    }
                }
            }
            
            const metadata = dungeonData.metadata;
            if (metadata && metadata.start && metadata.end) {
                const startX = Math.floor(metadata.start.x / ratio);
                const startY = Math.floor(metadata.start.y / ratio);
                const endX = Math.floor(metadata.end.x / ratio);
                const endY = Math.floor(metadata.end.y / ratio);
                
                if (startX > 0 && startX < 23 && startY > 0 && startY < 23) {
                    newMap.playerStart.X = startX;
                    newMap.playerStart.Y = startY;
                }
                
                if (endX > 0 && endX < 23 && endY > 0 && endY < 23) {
                    const exitSprite = createBaseSpriteAt(endX, endY, 'exit');
                    newMap.sprites.push(exitSprite);
                }
            }
            
            addRandomSpritesToDungeon(newMap);
            
            APP_STATE.allMaps.set(mapId, newMap);
            saveAllMaps();
            loadMapIntoEditor(mapId);
            
            showStatus(`Donjon import√© (ID: ${mapId})`, 'ok');
        }

        function addRandomSpritesToDungeon(mapData) {
            const floorCells = [];
            
            for (let y = 1; y < 23; y++) {
                for (let x = 1; x < 23; x++) {
                    if (mapData.map[y][x] === 0) {
                        floorCells.push({x, y});
                    }
                }
            }
            
            const spriteTypes = ['guard', 'merchant', 'bat', 'chest'];
            const numSprites = Math.min(8, Math.floor(floorCells.length / 10));
            
            for (let i = 0; i < numSprites; i++) {
                if (floorCells.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * floorCells.length);
                const pos = floorCells.splice(randomIndex, 1)[0];
                const spriteType = spriteTypes[Math.floor(Math.random() * spriteTypes.length)];
                
                const sprite = createBaseSpriteAt(pos.x, pos.y, spriteType);
                mapData.sprites.push(sprite);
            }
        }

        // Storage
        function saveAllMaps() {
            const mapsData = {};
            APP_STATE.allMaps.forEach((mapData, mapId) => {
                mapsData[mapId] = mapData;
            });
            localStorage.setItem('oasis_editor_maps_v4', JSON.stringify(mapsData));
        }

        function loadAllMaps() {
            try {
                const saved = localStorage.getItem('oasis_editor_maps_v4');
                if (saved) {
                    const mapsData = JSON.parse(saved);
                    Object.entries(mapsData).forEach(([mapId, mapData]) => {
                        APP_STATE.allMaps.set(parseInt(mapId), mapData);
                    });
                }
            } catch (error) {
                console.error('Error loading maps:', error);
            }
        }

        // Utility functions
        function clearMap() {
            if (confirm('Vider compl√®tement la carte ? Cette action est irr√©versible.')) {
                saveToHistory();
                
                APP_STATE.map = Array(24).fill().map(() => Array(24).fill(0));
                initializeBorders();
                
                APP_STATE.sprites = [];
                APP_STATE.teleporters = [];
                APP_STATE.selectedSprite = null;
                APP_STATE.selectedTeleporter = null;
                
                // Reset terrain mode to regular terrain
                APP_STATE.terrainMode = 'terrain';
                APP_STATE.selectedFloorTexture = null;
                
                markDirty();
                updateDisplay();
                updateTeleportList();
                validateCurrentMap();
                showStatus('Carte vid√©e', 'ok');
            }
        }

        function showStatus(message, type = 'ok') {
            const statusText = document.getElementById('status-text');
            const statusIndicator = statusText.parentElement.querySelector('.status-indicator');
            
            statusText.textContent = message;
            statusIndicator.className = `status-indicator status-${type}`;
            
            setTimeout(() => {
                statusText.textContent = 'Pr√™t';
                statusIndicator.className = 'status-indicator status-ok';
            }, 3000);
        }

        // Event listeners
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey) {
                    switch (e.key) {
                        case 'z':
                            e.preventDefault();
                            undoAction();
                            break;
                        case 'y':
                            e.preventDefault();
                            redoAction();
                            break;
                        case 's':
                            e.preventDefault();
                            saveCurrentMap();
                            break;
                        case 'n':
                            e.preventDefault();
                            if (confirm('Cr√©er une nouvelle carte ?')) {
                                createNewMap();
                            }
                            break;
                    }
                }
                
                // ESC pour annuler les modes
                if (e.key === 'Escape') {
                    APP_STATE.playerPositionMode = false;
                    APP_STATE.baseSpriteMode = null;
                    APP_STATE.customSpritePlacementMode = false;
                    APP_STATE.customSpriteConfig = null;
                    APP_STATE.teleportPlacementMode = null;
                    updateToolDisplay();
                    updateTeleportButtons();
                }
            });
            
            document.addEventListener('mouseup', () => {
                APP_STATE.isDrawing = false;
                APP_STATE.drawStart = null;
                removeDrawingPreview();
            });
            
            ['player-x', 'player-y', 'map-id'].forEach(id => {
                document.getElementById(id).addEventListener('input', validateCurrentMap);
            });
            
            // Initialize editor areas
            APP_STATE.editorShopItems = [];
        }

        // Initialize the application
        function init() {
            initializeBorders();
            createGrid();
            createCoordinateLabels();
            loadAllMaps();
            createNewMap();
            updateDisplay();
            setupEventListeners();
            validateCurrentMap();
            updateToolDisplay();
            
            // Nouveau : peupler les sprites de base
            populateBaseSpritesSection();
        }

        // Initialize the application
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>