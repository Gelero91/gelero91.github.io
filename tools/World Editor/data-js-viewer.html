<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âditeur Data.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .file-input-container {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: #2a2a2a;
            border-radius: 10px;
            border: 2px dashed #444;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: #4a90e2;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 16px;
            margin: 5px;
        }
        
        .file-input-label:hover {
            background: #357abd;
        }
        
        #fileInput, #folderInput {
            display: none;
        }
        
        .stats {
            margin: 20px 0;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            display: none;
        }
        
        .stats h2 {
            margin-bottom: 15px;
            color: #4a90e2;
        }
        
        .stat-item {
            margin: 10px 0;
            font-size: 14px;
        }
        
        .categories {
            margin-bottom: 30px;
            display: none;
        }
        
        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .category-tab {
            padding: 10px 20px;
            background: #333;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .category-tab:hover {
            background: #444;
        }
        
        .category-tab.active {
            background: #4a90e2;
            color: white;
        }
        
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .image-card {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 15px;
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
        }
        
        .image-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        
        .image-preview {
            width: 100%;
            height: 150px;
            background: #1a1a1a;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            margin-bottom: 10px;
            image-rendering: pixelated;
            cursor: pointer;
        }
        
        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        
        .image-name {
            font-weight: bold;
            margin-bottom: 5px;
            color: #4a90e2;
            word-break: break-all;
            font-size: 14px;
        }
        
        .image-info {
            font-size: 12px;
            color: #999;
        }
        
        .image-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .action-btn {
            flex: 1;
            padding: 8px;
            background: #333;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            border-radius: 3px;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .action-btn:hover {
            background: #444;
        }
        
        .action-btn.delete {
            background: #d32f2f;
        }
        
        .action-btn.delete:hover {
            background: #b71c1c;
        }
        
        .action-btn:first-child:hover {
            background: #4a90e2;
        }
        
        .action-btn:nth-child(2):hover {
            background: #ff9800;
        }
        
        .add-card {
            background: #2a2a2a;
            border: 2px dashed #4a90e2;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 250px;
        }
        
        .add-card:hover {
            background: #333;
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        
        .add-card-icon {
            font-size: 48px;
            margin-bottom: 10px;
            color: #4a90e2;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 30px;
            color: #999;
            cursor: pointer;
            background: none;
            border: none;
        }
        
        .modal-close:hover {
            color: #fff;
        }
        
        .modal-image {
            max-width: 100%;
            display: block;
            margin: 0 auto 20px;
            image-rendering: pixelated;
        }
        
        .modal-details {
            text-align: left;
        }
        
        .modal-details h3 {
            margin-bottom: 15px;
            color: #4a90e2;
        }
        
        .modal-details p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .error {
            background: #d32f2f;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            display: none;
        }
        
        .success {
            background: #4caf50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            display: none;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #4a90e2;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .floating-actions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .floating-btn {
            padding: 12px 24px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        
        .floating-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .floating-btn.save {
            background: #9c27b0;
        }
        
        .floating-btn.save:hover {
            background: #8e24aa;
        }
        
        .rename-input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 3px;
            margin-top: 10px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            display: none;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: #4a90e2;
            transition: width 0.3s;
            width: 0%;
        }
        
        .progress-text {
            text-align: center;
            font-size: 14px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="mainTitle">üé® √âditeur Data.js</h1>
        
        <div class="file-input-container">
            <label for="fileInput" class="file-input-label" onclick="openFile(event)">
                üìÅ Ouvrir Data.js
            </label>
            <input type="file" id="fileInput" accept=".js" style="display: none;">
            
            <label for="folderInput" class="file-input-label" style="background: #8bc34a;">
                üìÇ Importer dossier
            </label>
            <input type="file" id="folderInput" webkitdirectory directory multiple>
            
            <label for="multipleInput" class="file-input-label" style="background: #03a9f4;">
                üñºÔ∏è Importer images
            </label>
            <input type="file" id="multipleInput" accept="image/*" multiple style="display: none;">
            
            <p style="margin-top: 15px; color: #999;">Glissez-d√©posez un fichier Data.js, importez des images ou s√©lectionnez une option</p>
        </div>
        
        <div class="error" id="errorMessage"></div>
        <div class="success" id="successMessage"></div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px;">Chargement...</p>
        </div>
        
        <div class="progress-bar" id="progressBar">
            <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>
        <div class="progress-text" id="progressText"></div>
        
        <div class="stats" id="stats">
            <h2>üìä Statistiques</h2>
            <div id="statsContent"></div>
        </div>
        
        <div class="categories" id="categories">
            <div class="category-tabs" id="categoryTabs"></div>
        </div>
        
        <div class="image-grid" id="imageGrid"></div>
        
        <div class="floating-actions" id="floatingActions" style="display: none;">
            <button class="floating-btn save" onclick="saveDataJs()" title="Sauvegarder (Ctrl+S)">
                üíæ Sauvegarder
            </button>
            <button class="floating-btn save" onclick="saveDataJsAs()" style="background: #7b1fa2;">
                üíæ Sauvegarder sous...
            </button>
            <button class="floating-btn" onclick="downloadAllImages()" style="background: #ff9800;" title="T√©l√©charge toutes les images individuellement">
                ‚¨áÔ∏è T√©l√©charger toutes les images
            </button>
            <button class="floating-btn" onclick="exportData()">
                üìä Exporter JSON
            </button>
        </div>
    </div>
    
    <div class="modal" id="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <img id="modalImage" class="modal-image">
            <div class="modal-details">
                <h3 id="modalTitle"></h3>
                <div id="modalDetails"></div>
            </div>
        </div>
    </div>
    
    <script>
        let IMAGES = {};
        let categorizedImages = {};
        let currentCategory = 'all';
        let isModified = false;
        let fileHandle = null; // Pour stocker la r√©f√©rence au fichier original
        
        // Configuration des cat√©gories
        const categoryConfig = {
            'skybox': { pattern: /skybox/i, label: 'üåÖ Skybox', color: '#ff9800' },
            'floor': { pattern: /floor/i, label: 'üü´ Sol', color: '#8bc34a' },
            'ceiling': { pattern: /ceiling/i, label: '‚òÅÔ∏è Plafond', color: '#03a9f4' },
            'walls': { pattern: /wall/i, label: 'üß± Murs', color: '#795548' },
            'sprites': { pattern: /sprite/i, label: 'üëæ Sprites', color: '#e91e63' },
            'faces': { pattern: /face/i, label: 'üòä Visages', color: '#ffc107' },
            'icons': { pattern: /icon/i, label: 'üéØ Ic√¥nes', color: '#9c27b0' },
            'other': { pattern: /.*/, label: 'üì¶ Autres', color: '#607d8b' }
        };
        
        // Nouvelle fonction pour ouvrir un fichier
        async function openFile(event) {
            event.preventDefault();
            
            // V√©rifier si on est dans un contexte qui supporte l'API
            const canUseFileSystemAPI = 'showOpenFilePicker' in window && 
                                       window.self === window.top; // Pas dans une iframe
            
            if (canUseFileSystemAPI) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'JavaScript Files',
                            accept: {
                                'text/javascript': ['.js']
                            }
                        }],
                        multiple: false
                    });
                    
                    const file = await handle.getFile();
                    fileHandle = handle; // Sauvegarder le handle pour les sauvegardes futures
                    handleFile(file);
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.log('API File System non disponible, utilisation du s√©lecteur classique');
                        // Fallback vers l'input file classique
                        document.getElementById('fileInput').click();
                    }
                }
            } else {
                // Utiliser directement l'input file classique
                document.getElementById('fileInput').click();
            }
        }
        
        // Gestion du glisser-d√©poser
        const fileInputContainer = document.querySelector('.file-input-container');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileInputContainer.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            fileInputContainer.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            fileInputContainer.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight(e) {
            fileInputContainer.style.background = '#3a3a3a';
            fileInputContainer.style.borderColor = '#4a90e2';
        }
        
        function unhighlight(e) {
            fileInputContainer.style.background = '#2a2a2a';
            fileInputContainer.style.borderColor = '#444';
        }
        
        fileInputContainer.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }
        
        // Gestion des fichiers
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // Import de dossier
        document.getElementById('folderInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                await importFromFolder(files);
            }
        });
        
        // Import multiple d'images
        document.getElementById('multipleInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                await importFromFolder(files);
            }
        });
        
        function handleFile(file) {
            if (!file.name.endsWith('.js')) {
                showError('Veuillez s√©lectionner un fichier .js');
                return;
            }
            
            // Si le fichier n'est pas ouvert via l'API File System Access, r√©initialiser fileHandle
            if (!('showOpenFilePicker' in window) || window.self !== window.top) {
                fileHandle = null;
            }
            
            showLoading(true);
            hideError();
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    let content = e.target.result;
                    
                    // M√©thode 1 : Recherche par regex pour diff√©rents patterns de d√©claration
                    let imagesMatch = content.match(/(?:const|let|var)\s+IMAGES\s*=\s*({[\s\S]*?});/);
                    
                    if (!imagesMatch) {
                        // M√©thode 2 : Si IMAGES est assign√© sans d√©claration
                        imagesMatch = content.match(/IMAGES\s*=\s*({[\s\S]*?});/);
                    }
                    
                    if (!imagesMatch) {
                        // M√©thode 3 : Si c'est juste un objet export√©
                        imagesMatch = content.match(/export\s+(?:default\s+)?({[\s\S]*?});/);
                    }
                    
                    if (imagesMatch && imagesMatch[1]) {
                        // √âvaluer l'objet trouv√©
                        try {
                            // Utiliser Function pour cr√©er un contexte isol√©
                            const func = new Function('return ' + imagesMatch[1]);
                            IMAGES = func();
                        } catch (evalError) {
                            // Si l'√©valuation √©choue, essayer une approche plus s√ªre
                            console.warn('√âvaluation directe √©chou√©e, tentative d\'analyse alternative');
                            IMAGES = parseImageObject(imagesMatch[1]);
                        }
                    } else {
                        // M√©thode 4 : Dernier recours - chercher tout objet contenant des data URLs
                        const dataUrlPattern = /["']([^"']+)["']\s*:\s*["'](data:image\/[^"']+)["']/g;
                        const matches = [...content.matchAll(dataUrlPattern)];
                        
                        if (matches.length > 0) {
                            IMAGES = {};
                            matches.forEach(match => {
                                IMAGES[match[1]] = match[2];
                            });
                        } else {
                            throw new Error('Impossible de trouver un objet IMAGES valide dans le fichier');
                        }
                    }
                    
                    if (!IMAGES || typeof IMAGES !== 'object' || Object.keys(IMAGES).length === 0) {
                        throw new Error('Aucune image trouv√©e dans le fichier');
                    }
                    
                    console.log(`‚úÖ ${Object.keys(IMAGES).length} images trouv√©es`);
                    processImages();
                    showLoading(false);
                    setModified(false);
                } catch (error) {
                    showError('Erreur lors du parsing du fichier : ' + error.message);
                    showLoading(false);
                    console.error('Erreur d√©taill√©e:', error);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Fonction auxiliaire pour parser l'objet en cas d'√©chec de l'√©valuation
        function parseImageObject(objString) {
            const result = {};
            // Pattern pour capturer les paires cl√©-valeur avec des data URLs
            const pattern = /["']([^"']+)["']\s*:\s*["'](data:image\/[^"']+)["']/g;
            let match;
            
            while ((match = pattern.exec(objString)) !== null) {
                result[match[1]] = match[2];
            }
            
            return result;
        }
        
        // Fonction pour mettre √† jour le titre avec l'indicateur de modification
        function updateTitle() {
            const title = document.getElementById('mainTitle');
            const imageCount = Object.keys(IMAGES).length;
            let titleText = 'üé® √âditeur Data.js';
            
            if (imageCount > 0) {
                titleText += ` <span style="color: #888; font-size: 0.8em;">(${imageCount} images)</span>`;
            }
            
            if (isModified) {
                titleText += ' <span style="color: #ff9800;">‚óè</span>';
            }
            
            title.innerHTML = titleText;
        }
        
        // Fonction pour marquer comme modifi√©
        function setModified(value) {
            isModified = value;
            updateTitle();
        }
        
        async function importFromFolder(files) {
            showLoading(true);
            showProgress(true);
            hideError();
            
            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            
            if (imageFiles.length === 0) {
                showError('Aucune image trouv√©e');
                showLoading(false);
                showProgress(false);
                return;
            }
            
            // Demander confirmation si des images existent d√©j√†
            if (Object.keys(IMAGES).length > 0) {
                if (!confirm(`Ajouter ${imageFiles.length} images aux ${Object.keys(IMAGES).length} existantes ?`)) {
                    showLoading(false);
                    showProgress(false);
                    return;
                }
            }
            
            let processed = 0;
            const total = imageFiles.length;
            
            for (const file of imageFiles) {
                try {
                    const dataUrl = await fileToDataUrl(file);
                    // Extraire le nom sans extension et sans le chemin
                    let name = file.name.replace(/\.[^/.]+$/, '');
                    // Nettoyer le chemin (enlever tout avant le dernier /)
                    if (name.includes('/')) {
                        name = name.split('/').pop();
                    }
                    
                    // Si le nom existe d√©j√†, ajouter un suffixe
                    let finalName = name;
                    let counter = 1;
                    while (IMAGES[finalName]) {
                        finalName = `${name}_${counter}`;
                        counter++;
                    }
                    
                    IMAGES[finalName] = dataUrl;
                    
                    processed++;
                    updateProgress(processed, total, `Import: ${processed}/${total} fichiers`);
                } catch (error) {
                    console.error(`Erreur lors de l'import de ${file.name}:`, error);
                }
            }
            
            if (processed > 0) {
                processImages();
                showSuccess(`${processed} images import√©es avec succ√®s`);
                setModified(true);
            }
            
            showLoading(false);
            showProgress(false);
        }
        
        function fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        function processImages() {
            categorizedImages = {
                'all': []
            };
            
            // Initialiser les cat√©gories
            Object.keys(categoryConfig).forEach(key => {
                categorizedImages[key] = [];
            });
            
            // Traiter chaque image
            for (const [name, data] of Object.entries(IMAGES)) {
                if (typeof data === 'string' && data.startsWith('data:image')) {
                    const imageInfo = {
                        name: name,
                        data: data,
                        size: calculateBase64Size(data),
                        type: extractImageType(data)
                    };
                    
                    // Ajouter √† "all"
                    categorizedImages.all.push(imageInfo);
                    
                    // Cat√©goriser
                    let categorized = false;
                    for (const [category, config] of Object.entries(categoryConfig)) {
                        if (category !== 'other' && config.pattern.test(name)) {
                            categorizedImages[category].push(imageInfo);
                            categorized = true;
                            break;
                        }
                    }
                    
                    if (!categorized) {
                        categorizedImages.other.push(imageInfo);
                    }
                }
            }
            
            // Trier toutes les cat√©gories avec un tri naturel
            Object.keys(categorizedImages).forEach(category => {
                categorizedImages[category].sort(naturalSort);
            });
            
            displayStats();
            displayCategories();
            displayImages('all');
            document.getElementById('floatingActions').style.display = 'flex';
            updateTitle();
            
            // Mettre √† jour le texte du bouton de sauvegarde
            const saveBtn = document.querySelector('.floating-btn.save');
            if (fileHandle) {
                saveBtn.innerHTML = 'üíæ Sauvegarder';
                saveBtn.title = 'Sauvegarder (Ctrl+S)';
            } else {
                saveBtn.innerHTML = 'üíæ Sauvegarder';
                saveBtn.title = 'Sauvegarder sous... (Ctrl+S)';
            }
        }
        
        // Fonction de tri naturel pour les noms d'images
        function naturalSort(a, b) {
            const aName = a.name.toLowerCase();
            const bName = b.name.toLowerCase();
            
            // Fonction pour diviser une cha√Æne en parties num√©riques et non-num√©riques
            const tokenize = (str) => {
                const tokens = [];
                let match;
                const regex = /(\d+|\D+)/g;
                while ((match = regex.exec(str)) !== null) {
                    tokens.push(match[0]);
                }
                return tokens;
            };
            
            const aParts = tokenize(aName);
            const bParts = tokenize(bName);
            
            // Comparer partie par partie
            for (let i = 0; i < Math.min(aParts.length, bParts.length); i++) {
                const aPart = aParts[i];
                const bPart = bParts[i];
                
                // Si les deux parties sont des nombres
                if (/^\d+$/.test(aPart) && /^\d+$/.test(bPart)) {
                    const aNum = parseInt(aPart, 10);
                    const bNum = parseInt(bPart, 10);
                    if (aNum !== bNum) {
                        return aNum - bNum;
                    }
                } else {
                    // Comparaison alphab√©tique
                    if (aPart < bPart) return -1;
                    if (aPart > bPart) return 1;
                }
            }
            
            // Si toutes les parties compar√©es sont √©gales, comparer les longueurs
            return aParts.length - bParts.length;
        }
        
        function calculateBase64Size(base64String) {
            const base64 = base64String.split(',')[1];
            const padding = (base64.match(/=/g) || []).length;
            return Math.round((base64.length * 3 / 4) - padding);
        }
        
        function extractImageType(dataUrl) {
            const match = dataUrl.match(/data:image\/([^;]+)/);
            return match ? match[1] : 'unknown';
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return Math.round(bytes / 1024) + ' KB';
            else return Math.round(bytes / 1048576) + ' MB';
        }
        
        function displayStats() {
            const stats = document.getElementById('stats');
            const statsContent = document.getElementById('statsContent');
            
            let totalSize = 0;
            let imageCount = categorizedImages.all.length;
            
            categorizedImages.all.forEach(img => {
                totalSize += img.size;
            });
            
            let statsHTML = `
                <div class="stat-item">üìä <strong>Total d'images :</strong> ${imageCount}</div>
                <div class="stat-item">üíæ <strong>Taille totale :</strong> ${formatFileSize(totalSize)}</div>
            `;
            
            // Stats par cat√©gorie
            for (const [category, config] of Object.entries(categoryConfig)) {
                if (category !== 'all' && categorizedImages[category].length > 0) {
                    statsHTML += `<div class="stat-item">${config.label} : ${categorizedImages[category].length} images</div>`;
                }
            }
            
            statsContent.innerHTML = statsHTML;
            stats.style.display = 'block';
        }
        
        function displayCategories() {
            const categories = document.getElementById('categories');
            const categoryTabs = document.getElementById('categoryTabs');
            
            let tabsHTML = '<button class="category-tab active" onclick="selectCategory(\'all\')">üé® Toutes</button>';
            
            for (const [category, config] of Object.entries(categoryConfig)) {
                if (categorizedImages[category] && categorizedImages[category].length > 0) {
                    tabsHTML += `<button class="category-tab" onclick="selectCategory('${category}')">${config.label} (${categorizedImages[category].length})</button>`;
                }
            }
            
            categoryTabs.innerHTML = tabsHTML;
            categories.style.display = 'block';
        }
        
        function selectCategory(category) {
            currentCategory = category;
            
            // Mettre √† jour les onglets actifs
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            displayImages(category);
        }
        
        function displayImages(category) {
            const imageGrid = document.getElementById('imageGrid');
            const images = categorizedImages[category] || [];
            
            imageGrid.innerHTML = '';
            
            // Ajouter la carte d'ajout en premier (sauf pour "all")
            if (category !== 'all') {
                const addCard = document.createElement('div');
                addCard.className = 'image-card add-card';
                addCard.onclick = () => addNewImage(category);
                addCard.innerHTML = `
                    <div class="add-card-icon">‚ûï</div>
                    <div>Ajouter une image</div>
                `;
                imageGrid.appendChild(addCard);
            }
            
            images.forEach((imageInfo, index) => {
                const card = document.createElement('div');
                card.className = 'image-card';
                card.id = `card-${imageInfo.name}`;
                
                const img = new Image();
                img.onload = () => {
                    imageInfo.width = img.width;
                    imageInfo.height = img.height;
                };
                img.src = imageInfo.data;
                
                card.innerHTML = `
                    <div class="image-preview" onclick="showModal('${imageInfo.name}')">
                        <img src="${imageInfo.data}" alt="${imageInfo.name}">
                    </div>
                    <div class="image-name" id="name-${imageInfo.name}">${imageInfo.name}</div>
                    <div class="image-info">
                        ${formatFileSize(imageInfo.size)} ‚Ä¢ ${imageInfo.type.toUpperCase()}
                    </div>
                    <div class="image-actions">
                        <button class="action-btn" onclick="downloadImage('${imageInfo.name}')" title="T√©l√©charger">‚¨áÔ∏è</button>
                        <button class="action-btn" onclick="renameImage('${imageInfo.name}')" title="Renommer">‚úèÔ∏è</button>
                        <button class="action-btn delete" onclick="deleteImage('${imageInfo.name}')" title="Supprimer">üóëÔ∏è</button>
                    </div>
                `;
                
                imageGrid.appendChild(card);
            });
        }
        
        function addNewImage(category) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const name = prompt('Nom de l\'image (sans extension):', file.name.replace(/\.[^/.]+$/, ''));
                    
                    if (name) {
                        if (IMAGES[name]) {
                            if (!confirm(`Une image "${name}" existe d√©j√†. La remplacer ?`)) {
                                return;
                            }
                        }
                        
                        try {
                            const dataUrl = await fileToDataUrl(file);
                            IMAGES[name] = dataUrl;
                            setModified(true);
                            processImages();
                            selectCategory(category);
                            showSuccess(`Image "${name}" ajout√©e avec succ√®s`);
                        } catch (error) {
                            showError('Erreur lors de l\'ajout de l\'image');
                        }
                    }
                }
            };
            input.click();
        }
        
        function renameImage(oldName) {
            const nameElement = document.getElementById(`name-${oldName}`);
            const currentName = nameElement.textContent;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'rename-input';
            
            input.onblur = () => finishRename();
            input.onkeydown = (e) => {
                if (e.key === 'Enter') finishRename();
                if (e.key === 'Escape') cancelRename();
            };
            
            function finishRename() {
                const newName = input.value.trim();
                if (newName && newName !== oldName) {
                    // V√©rifier si le nouveau nom existe d√©j√† (mais pas si c'est le m√™me)
                    if (IMAGES[newName] && newName !== oldName) {
                        alert('Ce nom existe d√©j√†');
                        cancelRename();
                        return;
                    }
                    
                    // Renommer l'image
                    IMAGES[newName] = IMAGES[oldName];
                    delete IMAGES[oldName];
                    setModified(true);
                    processImages();
                    displayImages(currentCategory);
                    showSuccess(`Image renomm√©e de "${oldName}" √† "${newName}"`);
                } else {
                    cancelRename();
                }
            }
            
            function cancelRename() {
                nameElement.textContent = oldName;
            }
            
            nameElement.textContent = '';
            nameElement.appendChild(input);
            input.focus();
            input.select();
        }
        
        function deleteImage(name) {
            if (confirm(`√ätes-vous s√ªr de vouloir supprimer "${name}" ?`)) {
                delete IMAGES[name];
                setModified(true);
                processImages();
                displayImages(currentCategory);
                showSuccess(`Image "${name}" supprim√©e`);
            }
        }
        
        function downloadImage(name) {
            const dataUrl = IMAGES[name];
            if (!dataUrl) return;
            
            // Extraire le type et cr√©er le bon nom de fichier
            const match = dataUrl.match(/^data:image\/([^;]+);/);
            const extension = match ? match[1].replace('jpeg', 'jpg') : 'png';
            
            // Cr√©er un lien de t√©l√©chargement
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = `${name}.${extension}`;
            a.click();
        }
        
        async function downloadAllImages() {
            if (!confirm(`T√©l√©charger ${Object.keys(IMAGES).length} images individuellement ?\n\nNote : Les images seront t√©l√©charg√©es une par une dans votre dossier de t√©l√©chargements.`)) {
                return;
            }
            
            showProgress(true);
            let downloaded = 0;
            const total = Object.keys(IMAGES).length;
            
            // Obtenir les entr√©es et les trier avec le tri naturel
            const entries = Object.entries(IMAGES);
            entries.sort((a, b) => {
                const aInfo = { name: a[0] };
                const bInfo = { name: b[0] };
                return naturalSort(aInfo, bInfo);
            });
            
            for (const [name, dataUrl] of entries) {
                // Extraire le type et cr√©er le bon nom de fichier
                const match = dataUrl.match(/^data:image\/([^;]+);/);
                const extension = match ? match[1].replace('jpeg', 'jpg') : 'png';
                
                // Cr√©er un lien de t√©l√©chargement
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `${name}.${extension}`;
                a.click();
                
                downloaded++;
                updateProgress(downloaded, total, `T√©l√©chargement: ${downloaded}/${total} fichiers`);
                
                // Petit d√©lai pour √©viter de surcharger le navigateur
                await new Promise(resolve => setTimeout(resolve, 150));
            }
            
            showProgress(false);
            showSuccess('Toutes les images ont √©t√© t√©l√©charg√©es');
        }
        
        function showModal(imageName) {
            const imageInfo = categorizedImages.all.find(img => img.name === imageName);
            if (!imageInfo) return;
            
            const modal = document.getElementById('modal');
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalDetails = document.getElementById('modalDetails');
            
            modalImage.src = imageInfo.data;
            modalTitle.textContent = imageInfo.name;
            
            const img = new Image();
            img.onload = () => {
                modalDetails.innerHTML = `
                    <p><strong>Type :</strong> ${imageInfo.type.toUpperCase()}</p>
                    <p><strong>Taille :</strong> ${formatFileSize(imageInfo.size)}</p>
                    <p><strong>Dimensions :</strong> ${img.width} √ó ${img.height} pixels</p>
                    <p><strong>Data URL :</strong></p>
                    <textarea style="width: 100%; height: 100px; margin-top: 10px; background: #1a1a1a; color: #e0e0e0; border: 1px solid #444; border-radius: 5px; padding: 10px; font-family: monospace; font-size: 12px;" readonly>${imageInfo.data}</textarea>
                `;
            };
            img.src = imageInfo.data;
            
            modal.style.display = 'flex';
        }
        
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
        }
        
        // Fermer la modal en cliquant √† l'ext√©rieur
        document.getElementById('modal').addEventListener('click', (e) => {
            if (e.target.id === 'modal') {
                closeModal();
            }
        });
        
        // Fermer avec Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
            
            // Ctrl+S pour sauvegarder
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                if (isModified && document.getElementById('floatingActions').style.display !== 'none') {
                    saveDataJs();
                }
            }
        });
        
        async function exportToZip() {
            showLoading(true);
            showProgress(true);
            
            const zip = new JSZip();
            const dataFolder = zip.folder("DATA");
            
            let processed = 0;
            const total = Object.keys(IMAGES).length;
            
            for (const [name, dataUrl] of Object.entries(IMAGES)) {
                try {
                    // Extraire le type et les donn√©es
                    const match = dataUrl.match(/^data:image\/([^;]+);base64,(.+)$/);
                    if (match) {
                        const extension = match[1].replace('jpeg', 'jpg');
                        const base64Data = match[2];
                        
                        // Ajouter le fichier au ZIP
                        dataFolder.file(`${name}.${extension}`, base64Data, { base64: true });
                        
                        processed++;
                        updateProgress(processed, total, `Export: ${processed}/${total} fichiers`);
                    }
                } catch (error) {
                    console.error(`Erreur lors de l'export de ${name}:`, error);
                }
            }
            
            // G√©n√©rer et t√©l√©charger le ZIP
            zip.generateAsync({ type: "blob" })
                .then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = "DATA.zip";
                    a.click();
                    URL.revokeObjectURL(url);
                    showSuccess('Export ZIP termin√© avec succ√®s');
                    showLoading(false);
                    showProgress(false);
                });
        }
        
        async function saveDataJs() {
            let content = 'const IMAGES = {\n';
            
            // Obtenir les entr√©es et les trier avec le tri naturel
            const entries = Object.entries(IMAGES);
            entries.sort((a, b) => {
                const aInfo = { name: a[0] };
                const bInfo = { name: b[0] };
                return naturalSort(aInfo, bInfo);
            });
            
            entries.forEach(([name, data], index) => {
                content += `    "${name}": "${data}"`;
                if (index < entries.length - 1) {
                    content += ',';
                }
                content += '\n';
            });
            
            content += '};\n';
            
            // V√©rifier si on peut utiliser l'API File System
            const canUseFileSystemAPI = fileHandle && 
                                       'createWritable' in fileHandle && 
                                       window.self === window.top;
            
            // Si on a un handle de fichier et qu'on peut l'utiliser
            if (canUseFileSystemAPI) {
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    setModified(false);
                    showSuccess('Fichier sauvegard√© directement');
                    return;
                } catch (err) {
                    console.log('Sauvegarde directe √©chou√©e, utilisation du t√©l√©chargement');
                    // Continuer avec saveAs si erreur
                }
            }
            
            // Sinon, faire "Sauvegarder sous"
            await saveDataJsAs();
        }
        
        async function saveDataJsAs() {
            let content = 'const IMAGES = {\n';
            
            // Obtenir les entr√©es et les trier avec le tri naturel
            const entries = Object.entries(IMAGES);
            entries.sort((a, b) => {
                const aInfo = { name: a[0] };
                const bInfo = { name: b[0] };
                return naturalSort(aInfo, bInfo);
            });
            
            entries.forEach(([name, data], index) => {
                content += `    "${name}": "${data}"`;
                if (index < entries.length - 1) {
                    content += ',';
                }
                content += '\n';
            });
            
            content += '};\n';
            
            // V√©rifier si on peut utiliser l'API File System
            const canUseFileSystemAPI = 'showSaveFilePicker' in window && 
                                       window.self === window.top;
            
            if (canUseFileSystemAPI) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'Data.js',
                        types: [{
                            description: 'JavaScript Files',
                            accept: {
                                'text/javascript': ['.js']
                            }
                        }]
                    });
                    
                    const writable = await handle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    fileHandle = handle; // Sauvegarder le handle pour les sauvegardes futures
                    setModified(false);
                    showSuccess('Fichier sauvegard√©');
                    return;
                } catch (err) {
                    // L'utilisateur a annul√© ou erreur
                    if (err.name !== 'AbortError') {
                        console.log('API File System non disponible, utilisation du t√©l√©chargement');
                    } else {
                        return; // L'utilisateur a annul√©, ne pas continuer
                    }
                }
            }
            
            // Fallback : t√©l√©chargement classique
            const blob = new Blob([content], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Data.js';
            a.click();
            URL.revokeObjectURL(url);
            
            setModified(false);
            showSuccess('Fichier Data.js t√©l√©charg√©');
        }
        
        function exportData() {
            const exportData = {
                stats: {
                    totalImages: categorizedImages.all.length,
                    totalSize: categorizedImages.all.reduce((sum, img) => sum + img.size, 0),
                    categories: {}
                },
                images: {}
            };
            
            // Statistiques par cat√©gorie
            for (const [category, images] of Object.entries(categorizedImages)) {
                if (category !== 'all' && images.length > 0) {
                    exportData.stats.categories[category] = images.length;
                }
            }
            
            // D√©tails des images
            categorizedImages.all.forEach(img => {
                exportData.images[img.name] = {
                    type: img.type,
                    size: img.size,
                    width: img.width,
                    height: img.height
                };
            });
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'data-js-analysis.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => hideError(), 5000);
        }
        
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
        
        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => hideSuccess(), 3000);
        }
        
        function hideSuccess() {
            document.getElementById('successMessage').style.display = 'none';
        }
        
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        function showProgress(show) {
            document.getElementById('progressBar').style.display = show ? 'block' : 'none';
            if (!show) {
                document.getElementById('progressText').textContent = '';
            }
        }
        
        function updateProgress(current, total, text) {
            const percentage = (current / total) * 100;
            document.getElementById('progressBarFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = text;
        }
        
        // Avertir avant de quitter si modifications non sauvegard√©es
        window.addEventListener('beforeunload', (e) => {
            if (isModified) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>