<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Donjons 2D - Architecture Intelligente</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #ddd;
            overflow: hidden;
            height: 100vh;
        }
        
        .container {
            display: flex;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 15px;
            overflow-y: auto;
            width: 320px;
            flex-shrink: 0;
        }
        
        .controls h2 { font-size: 20px; margin-bottom: 15px; color: #fff; }
        .controls h3 { font-size: 16px; margin: 15px 0 10px 0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
        
        .control-group {
            margin-bottom: 12px;
            font-size: 13px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: #ccc;
        }
        
        input[type="range"], input[type="text"], select {
            width: 100%;
            height: 24px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
        }
        
        select {
            padding: 2px;
        }
        
        input[type="checkbox"] {
            margin-right: 6px;
            width: 16px;
            height: 16px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            background: #555;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 14px;
            border-radius: 3px;
        }
        
        button:hover { background: #666; }
        .primary-btn { background: #4a4; font-weight: bold; }
        .primary-btn:hover { background: #5b5; }
        
        .stats {
            margin-top: 15px;
            padding: 10px;
            background: #333;
            font-size: 12px;
            line-height: 1.6;
            border-radius: 3px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 10px;
            margin-top: 5px;
        }
        
        .stats-label { color: #aaa; }
        .stats-value { text-align: right; }
        
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .canvas-wrapper {
            background: #2a2a2a;
            padding: 10px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        
        #canvas {
            border: 1px solid #444;
            max-width: 100%;
            max-height: 100%;
        }
        
        .info-panel {
            background: #2a2a2a;
            padding: 12px;
            border-radius: 3px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            border: 1px solid #555;
        }
        
        .value-display {
            float: right;
            color: #888;
            font-weight: bold;
        }
        
        .mode-description {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
            font-style: italic;
        }
        
        .warning {
            color: #f88;
            font-size: 11px;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>Générateur de Donjons Intelligent</h2>
            
            <h3>Mode Architectural</h3>
            <div class="control-group">
                <label>Type de donjon:</label>
                <select id="dungeonMode">
                    <option value="fortress">Forteresse</option>
                    <option value="cave">Caverne</option>
                    <option value="temple">Temple</option>
                    <option value="crypt">Crypte</option>
                    <option value="mixed" selected>Mixte</option>
                </select>
                <div class="mode-description" id="modeDescription">
                    Combine différents styles architecturaux par zones
                </div>
            </div>
            
            <div class="control-group">
                <label>Seed: <input type="text" id="seed" placeholder="Aléatoire"></label>
            </div>

            <h3>Paramètres de Génération</h3>
            
            <div class="control-group">
                <label>Taille du donjon: <span class="value-display" id="dungeonSizeValue">Moyen</span>
                <input type="range" id="dungeonSize" min="1" max="3" value="2"></label>
            </div>
            
            <div class="control-group">
                <label>Densité des salles: <span class="value-display" id="roomDensityValue">50%</span>
                <input type="range" id="roomDensity" min="20" max="80" value="50"></label>
            </div>
            
            <div class="control-group">
                <label>Complexité des chemins: <span class="value-display" id="pathComplexityValue">50%</span>
                <input type="range" id="pathComplexity" min="0" max="100" value="50"></label>
            </div>

            <h3>Options Avancées</h3>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="generateMazes" checked>
                    Générer des labyrinthes de remplissage
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="ensureMultiplePaths" checked>
                    Garantir plusieurs chemins
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="placeSecrets">
                    Ajouter des salles secrètes
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="markDeadEnds" checked>
                    Marquer les culs-de-sac (loot)
                </label>
            </div>

            <h3>Visualisation</h3>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showGrid">
                    Afficher la grille
                </label>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showRoomTypes" checked>
                    Différencier les types de salles
                </label>
            </div>

            <button id="generateBtn" class="primary-btn">Générer Nouveau Donjon</button>
            <button id="analyzeBtn">Analyser la Qualité</button>
            <button id="exportBtn">Exporter JSON</button>
            
            <div class="stats">
                <h4 style="margin: 0 0 8px 0;">Statistiques</h4>
                <div class="stats-grid">
                    <span class="stats-label">Salles principales:</span>
                    <span class="stats-value" id="mainRooms">0</span>
                    
                    <span class="stats-label">Salles secondaires:</span>
                    <span class="stats-value" id="secondaryRooms">0</span>
                    
                    <span class="stats-label">Espaces libres:</span>
                    <span class="stats-value" id="openSpaces">0%</span>
                    
                    <span class="stats-label">Culs-de-sac:</span>
                    <span class="stats-value" id="deadEnds">0</span>
                    
                    <span class="stats-label">Distance S→E:</span>
                    <span class="stats-value" id="pathDistance">0</span>
                    
                    <span class="stats-label">Chemins alternatifs:</span>
                    <span class="stats-value" id="altPaths">0</span>
                </div>
                
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444;">
                    <strong>Qualité:</strong> <span id="qualityScore" style="color: #4a4;">Non évalué</span>
                    <div id="qualityWarnings" style="margin-top: 5px;"></div>
                </div>
            </div>
        </div>
        
        <div class="main-area">
            <div class="canvas-wrapper">
                <canvas id="canvas" width="640" height="640"></canvas>
            </div>
            
            <div class="info-panel">
                <div class="legend">
                    <div class="legend-item">
                        <span class="legend-color" style="background: #222"></span>
                        <span>Mur</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #e8e8e8"></span>
                        <span>Salle principale</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #b8b8b8"></span>
                        <span>Salle secondaire</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #888"></span>
                        <span>Corridor principal</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #666"></span>
                        <span>Labyrinthe</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #4a4"></span>
                        <span>Début (S)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #f44"></span>
                        <span>Fin (E)</span>
                    </div>
                    <div class="legend-item" id="deadEndLegend" style="display: flex">
                        <span class="legend-color" style="background: #fa0"></span>
                        <span>Cul-de-sac (loot)</span>
                    </div>
                    <div class="legend-item" id="secretLegend" style="display: none">
                        <span class="legend-color" style="background: #a4f"></span>
                        <span>Salle secrète</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// Configuration de base
const GRID_SIZE = 32;
const CELL_SIZE = 20;
const WALL = 1;
const FLOOR = 0;

// Types de cellules pour l'affichage
const CELL_TYPES = {
    WALL: 0,
    MAIN_ROOM: 1,
    SECONDARY_ROOM: 2,
    CORRIDOR: 3,
    MAZE: 4,
    SECRET: 5,
    START: 6,
    END: 7,
    DEAD_END: 8
};

// Modes de génération avec leurs paramètres
const DUNGEON_MODES = {
    fortress: {
        name: "Forteresse",
        description: "Salles rectangulaires, corridors droits, architecture ordonnée",
        roomShape: "rectangular",
        corridorStyle: "straight",
        roomSizeVariance: 0.3,
        mazeComplexity: 0.2,
        symmetry: 0.7
    },
    cave: {
        name: "Caverne",
        description: "Formes organiques, passages sinueux, aspect naturel",
        roomShape: "organic",
        corridorStyle: "winding",
        roomSizeVariance: 0.8,
        mazeComplexity: 0.8,
        symmetry: 0.1
    },
    temple: {
        name: "Temple",
        description: "Symétrie, grandes salles centrales, architecture sacrée",
        roomShape: "rectangular",
        corridorStyle: "straight",
        roomSizeVariance: 0.5,
        mazeComplexity: 0.3,
        symmetry: 0.9
    },
    crypt: {
        name: "Crypte",
        description: "Petites salles interconnectées, nombreux culs-de-sac",
        roomShape: "rectangular",
        corridorStyle: "maze-like",
        roomSizeVariance: 0.2,
        mazeComplexity: 0.9,
        symmetry: 0.4
    },
    mixed: {
        name: "Mixte",
        description: "Combine différents styles architecturaux par zones",
        roomShape: "mixed",
        corridorStyle: "mixed",
        roomSizeVariance: 0.6,
        mazeComplexity: 0.5,
        symmetry: 0.5
    }
};

// Variables globales
let dungeon = [];
let cellTypes = [];
let rooms = [];
let corridors = [];
let startPos = null;
let endPos = null;
let deadEndsList = [];
let pathDistance = 0;
let alternativePaths = 0;

// Classes utilitaires
class Random {
    constructor(seed) {
        this.seed = seed || Date.now();
    }
    
    next() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
    }
    
    nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
    
    nextFloat(min, max) {
        return this.next() * (max - min) + min;
    }
    
    chance(probability) {
        return this.next() < probability;
    }
}

// Classe pour les salles
class Room {
    constructor(x, y, width, height, type = 'main') {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = type; // 'main', 'secondary', 'secret'
        this.centerX = Math.floor(x + width / 2);
        this.centerY = Math.floor(y + height / 2);
        this.connections = [];
        this.zone = null; // Pour le mode mixte
    }
    
    intersects(other, padding = 1) {
        return !(this.x + this.width + padding <= other.x || 
                other.x + other.width + padding <= this.x || 
                this.y + this.height + padding <= other.y || 
                other.y + other.height + padding <= this.y);
    }
    
    distanceTo(other) {
        return Math.abs(this.centerX - other.centerX) + Math.abs(this.centerY - other.centerY);
    }
}

// Classe pour gérer les zones (pour le mode mixte)
class Zone {
    constructor(x, y, width, height, mode) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.mode = mode;
        this.rooms = [];
    }
    
    contains(x, y) {
        return x >= this.x && x < this.x + this.width &&
               y >= this.y && y < this.y + this.height;
    }
}

// Initialise le donjon
function initializeDungeon() {
    dungeon = [];
    cellTypes = [];
    
    for (let y = 0; y < GRID_SIZE; y++) {
        dungeon[y] = [];
        cellTypes[y] = [];
        for (let x = 0; x < GRID_SIZE; x++) {
            // Les bordures sont toujours des murs
            if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) {
                dungeon[y][x] = WALL;
                cellTypes[y][x] = CELL_TYPES.WALL;
            } else {
                dungeon[y][x] = WALL;
                cellTypes[y][x] = CELL_TYPES.WALL;
            }
        }
    }
}

// Génère les zones pour le mode mixte
function generateZones(rng) {
    const zones = [];
    const modes = ['fortress', 'cave', 'temple', 'crypt'];
    
    // Divise le donjon en 4 zones
    const halfSize = Math.floor(GRID_SIZE / 2);
    
    for (let i = 0; i < 4; i++) {
        const x = (i % 2) * halfSize;
        const y = Math.floor(i / 2) * halfSize;
        const mode = modes[rng.nextInt(0, modes.length - 1)];
        
        zones.push(new Zone(x, y, halfSize, halfSize, mode));
    }
    
    return zones;
}

// Génère une salle selon le mode
function generateRoom(x, y, width, height, mode, type = 'main') {
    const room = new Room(x, y, width, height, type);
    
    if (mode.roomShape === 'organic') {
        // Pour les cavernes, on pourrait modifier la forme
        // Pour l'instant, on garde rectangulaire mais on pourrait ajouter du bruit
    }
    
    return room;
}

// Place les salles principales
function placeMainRooms(rng, mode, density, zones = null) {
    const mainRooms = [];
    const dungeonSizeMultiplier = parseInt(document.getElementById('dungeonSize').value);
    
    // Calcule le nombre de salles selon la densité et la taille
    const baseRoomCount = 4 + dungeonSizeMultiplier * 2;
    const roomCount = Math.floor(baseRoomCount * (density / 50));
    
    // Tailles des salles selon le mode
    let minSize, maxSize;
    switch (mode.name) {
        case 'Crypte':
            minSize = 3;
            maxSize = 5;
            break;
        case 'Temple':
            minSize = 6;
            maxSize = 10;
            break;
        default:
            minSize = 4;
            maxSize = 8;
    }
    
    // Place les salles principales
    let attempts = 0;
    while (mainRooms.length < roomCount && attempts < 1000) {
        attempts++;
        
        const width = rng.nextInt(minSize, maxSize);
        const height = rng.nextInt(minSize, maxSize);
        const x = rng.nextInt(2, GRID_SIZE - width - 2);
        const y = rng.nextInt(2, GRID_SIZE - height - 2);
        
        const newRoom = generateRoom(x, y, width, height, mode, 'main');
        
        // Vérifie les intersections avec un padding de 2
        let valid = true;
        for (let room of mainRooms) {
            if (newRoom.intersects(room, 2)) {
                valid = false;
                break;
            }
        }
        
        if (valid) {
            // Si mode mixte, assigne la zone
            if (zones) {
                for (let zone of zones) {
                    if (zone.contains(newRoom.centerX, newRoom.centerY)) {
                        newRoom.zone = zone;
                        zone.rooms.push(newRoom);
                        break;
                    }
                }
            }
            
            mainRooms.push(newRoom);
            carveRoom(newRoom);
        }
    }
    
    return mainRooms;
}

// Place les salles secondaires
function placeSecondaryRooms(rng, mode, mainRooms) {
    const secondaryRooms = [];
    const secondaryCount = Math.floor(mainRooms.length * 0.5);
    
    let attempts = 0;
    while (secondaryRooms.length < secondaryCount && attempts < 500) {
        attempts++;
        
        // Taille plus petite pour les salles secondaires
        const width = rng.nextInt(3, 4);
        const height = rng.nextInt(3, 4);
        const x = rng.nextInt(2, GRID_SIZE - width - 2);
        const y = rng.nextInt(2, GRID_SIZE - height - 2);
        
        const newRoom = generateRoom(x, y, width, height, mode, 'secondary');
        
        // Vérifie les intersections
        let valid = true;
        for (let room of [...mainRooms, ...secondaryRooms]) {
            if (newRoom.intersects(room, 1)) {
                valid = false;
                break;
            }
        }
        
        if (valid) {
            secondaryRooms.push(newRoom);
            carveRoom(newRoom);
        }
    }
    
    return secondaryRooms;
}

// Creuse une salle dans le donjon
function carveRoom(room) {
    for (let y = room.y; y < room.y + room.height; y++) {
        for (let x = room.x; x < room.x + room.width; x++) {
            if (x > 0 && x < GRID_SIZE - 1 && y > 0 && y < GRID_SIZE - 1) {
                dungeon[y][x] = FLOOR;
                cellTypes[y][x] = room.type === 'main' ? CELL_TYPES.MAIN_ROOM : 
                                 room.type === 'secondary' ? CELL_TYPES.SECONDARY_ROOM :
                                 CELL_TYPES.SECRET;  
            }
        }
    }
}

// Connecte les salles avec des corridors
function connectRooms(rooms, rng, mode) {
    if (rooms.length < 2) return;
    
    // Crée un arbre couvrant minimum avec l'algorithme de Kruskal
    const edges = [];
    
    // Génère toutes les arêtes possibles
    for (let i = 0; i < rooms.length; i++) {
        for (let j = i + 1; j < rooms.length; j++) {
            edges.push({
                from: i,
                to: j,
                distance: rooms[i].distanceTo(rooms[j])
            });
        }
    }
    
    // Trie par distance
    edges.sort((a, b) => a.distance - b.distance);
    
    // Union-Find pour Kruskal
    const parent = Array(rooms.length).fill().map((_, i) => i);
    
    function find(x) {
        if (parent[x] !== x) parent[x] = find(parent[x]);
        return parent[x];
    }
    
    function union(x, y) {
        parent[find(x)] = find(y);
    }
    
    // Connecte les salles
    const connections = [];
    for (let edge of edges) {
        if (find(edge.from) !== find(edge.to)) {
            union(edge.from, edge.to);
            connections.push(edge);
            
            // Creuse le corridor
            const room1 = rooms[edge.from];
            const room2 = rooms[edge.to];
            
            if (mode.corridorStyle === 'straight') {
                carveCorridorStraight(room1.centerX, room1.centerY, room2.centerX, room2.centerY, rng);
            } else if (mode.corridorStyle === 'winding') {
                carveCorridorWinding(room1.centerX, room1.centerY, room2.centerX, room2.centerY, rng);
            } else {
                // Par défaut, corridor en L
                carveCorridorL(room1.centerX, room1.centerY, room2.centerX, room2.centerY, rng);
            }
            
            room1.connections.push(edge.to);
            room2.connections.push(edge.from);
        }
    }
    
    // Ajoute des connexions supplémentaires pour créer des boucles
    const extraConnections = Math.floor(rooms.length * 0.3);
    for (let i = 0; i < extraConnections && edges.length > 0; i++) {
        const edge = edges[rng.nextInt(0, edges.length - 1)];
        const room1 = rooms[edge.from];
        const room2 = rooms[edge.to];
        
        if (!room1.connections.includes(edge.to)) {
            carveCorridorL(room1.centerX, room1.centerY, room2.centerX, room2.centerY, rng);
            room1.connections.push(edge.to);
            room2.connections.push(edge.from);
        }
    }
}

// Creuse un corridor en L
function carveCorridorL(x1, y1, x2, y2, rng) {
    if (rng.next() < 0.5) {
        // Horizontal puis vertical
        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
            if (x > 0 && x < GRID_SIZE - 1 && y1 > 0 && y1 < GRID_SIZE - 1) {
                dungeon[y1][x] = FLOOR;
                if (cellTypes[y1][x] === CELL_TYPES.WALL) {
                    cellTypes[y1][x] = CELL_TYPES.CORRIDOR;
                }
            }
        }
        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
            if (x2 > 0 && x2 < GRID_SIZE - 1 && y > 0 && y < GRID_SIZE - 1) {
                dungeon[y][x2] = FLOOR;
                if (cellTypes[y][x2] === CELL_TYPES.WALL) {
                    cellTypes[y][x2] = CELL_TYPES.CORRIDOR;
                }
            }
        }
    } else {
        // Vertical puis horizontal
        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
            if (x1 > 0 && x1 < GRID_SIZE - 1 && y > 0 && y < GRID_SIZE - 1) {
                dungeon[y][x1] = FLOOR;
                if (cellTypes[y][x1] === CELL_TYPES.WALL) {
                    cellTypes[y][x1] = CELL_TYPES.CORRIDOR;
                }
            }
        }
        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
            if (x > 0 && x < GRID_SIZE - 1 && y2 > 0 && y2 < GRID_SIZE - 1) {
                dungeon[y2][x] = FLOOR;
                if (cellTypes[y2][x] === CELL_TYPES.WALL) {
                    cellTypes[y2][x] = CELL_TYPES.CORRIDOR;
                }
            }
        }
    }
}

// Creuse un corridor droit
function carveCorridorStraight(x1, y1, x2, y2, rng) {
    // Utilise l'algorithme de Bresenham pour une ligne droite
    let dx = Math.abs(x2 - x1);
    let dy = Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1;
    let sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    
    while (true) {
        if (x1 > 0 && x1 < GRID_SIZE - 1 && y1 > 0 && y1 < GRID_SIZE - 1) {
            dungeon[y1][x1] = FLOOR;
            if (cellTypes[y1][x1] === CELL_TYPES.WALL) {
                cellTypes[y1][x1] = CELL_TYPES.CORRIDOR;
            }
        }
        
        if (x1 === x2 && y1 === y2) break;
        
        let e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

// Creuse un corridor sinueux
function carveCorridorWinding(x1, y1, x2, y2, rng) {
    // Pour l'instant, utilise le corridor en L avec plus de variations
    // TODO: Implémenter un vrai algorithme de corridor sinueux
    carveCorridorL(x1, y1, x2, y2, rng);
}

// Génère des labyrinthes dans les espaces vides
function generateMazes(rng, complexity) {
    // Trouve les régions vides pour les labyrinthes
    const regions = findEmptyRegions();
    
    for (let region of regions) {
        // Ne génère des labyrinthes que dans les régions assez grandes
        if (region.length > 10) {
            generateMazeInRegion(region, rng, complexity);
        }
    }
}

// Trouve les régions vides (espacées des salles)
function findEmptyRegions() {
    const regions = [];
    const visited = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
    
    for (let y = 2; y < GRID_SIZE - 2; y++) {
        for (let x = 2; x < GRID_SIZE - 2; x++) {
            if (dungeon[y][x] === WALL && !visited[y][x] && canPlaceMaze(x, y)) {
                const region = floodFillRegion(x, y, visited);
                if (region.length > 10) {
                    regions.push(region);
                }
            }
        }
    }
    
    return regions;
}

// Vérifie si on peut placer un labyrinthe à cette position
function canPlaceMaze(x, y) {
    // Vérifie qu'on est à au moins 1 case d'une salle
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                const cellType = cellTypes[ny][nx];
                if (cellType === CELL_TYPES.MAIN_ROOM || 
                    cellType === CELL_TYPES.SECONDARY_ROOM ||
                    cellType === CELL_TYPES.SECRET) {
                    return false;
                }
            }
        }
    }
    return true;
}

// Flood fill pour trouver une région
function floodFillRegion(startX, startY, visited) {
    const region = [];
    const queue = [{x: startX, y: startY}];
    visited[startY][startX] = true;
    
    while (queue.length > 0) {
        const {x, y} = queue.shift();
        region.push({x, y});
        
        const directions = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}];
        for (let dir of directions) {
            const nx = x + dir.x;
            const ny = y + dir.y;
            
            if (nx > 1 && nx < GRID_SIZE - 1 && ny > 1 && ny < GRID_SIZE - 1 &&
                !visited[ny][nx] && dungeon[ny][nx] === WALL && canPlaceMaze(nx, ny)) {
                visited[ny][nx] = true;
                queue.push({x: nx, y: ny});
            }
        }
    }
    
    return region;
}

// Génère un labyrinthe dans une région
function generateMazeInRegion(region, rng, complexity) {
    // Utilise un algorithme de génération de labyrinthe adapté
    const mazeGrid = createMazeGrid(region);
    
    if (mazeGrid.length === 0) return;
    
    // Génère le labyrinthe avec Recursive Backtracking
    generateMazeRecursive(mazeGrid, rng);
    
    // Réduit la complexité si nécessaire
    if (complexity < 1) {
        reduceMazeComplexity(mazeGrid, complexity);
    }
    
    // Applique le labyrinthe au donjon
    applyMazeToDungeon(mazeGrid);
}

// Crée une grille pour le labyrinthe
function createMazeGrid(region) {
    // Trouve les limites de la région
    let minX = GRID_SIZE, maxX = 0, minY = GRID_SIZE, maxY = 0;
    for (let cell of region) {
        minX = Math.min(minX, cell.x);
        maxX = Math.max(maxX, cell.x);
        minY = Math.min(minY, cell.y);
        maxY = Math.max(maxY, cell.y);
    }
    
    // Crée un set pour accès rapide
    const regionSet = new Set(region.map(c => `${c.x},${c.y}`));
    
    // Crée la grille pour le labyrinthe (seulement les positions impaires)
    const mazeGrid = [];
    for (let y = minY; y <= maxY; y += 2) {
        for (let x = minX; x <= maxX; x += 2) {
            if (regionSet.has(`${x},${y}`)) {
                mazeGrid.push({x, y, visited: false, walls: {n: true, s: true, e: true, w: true}});
            }
        }
    }
    
    return mazeGrid;
}

// Génère le labyrinthe avec Recursive Backtracking
function generateMazeRecursive(mazeGrid, rng) {
    if (mazeGrid.length === 0) return;
    
    // Crée une map pour accès rapide
    const gridMap = new Map();
    for (let cell of mazeGrid) {
        gridMap.set(`${cell.x},${cell.y}`, cell);
    }
    
    // Commence avec une cellule aléatoire
    const stack = [];
    const start = mazeGrid[rng.nextInt(0, mazeGrid.length - 1)];
    start.visited = true;
    stack.push(start);
    
    while (stack.length > 0) {
        const current = stack[stack.length - 1];
        
        // Trouve les voisins non visités
        const neighbors = [];
        const directions = [
            {dx: 0, dy: -2, wall: 'n', opposite: 's'},
            {dx: 2, dy: 0, wall: 'e', opposite: 'w'},
            {dx: 0, dy: 2, wall: 's', opposite: 'n'},
            {dx: -2, dy: 0, wall: 'w', opposite: 'e'}
        ];
        
        for (let dir of directions) {
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            const neighbor = gridMap.get(`${nx},${ny}`);
            
            if (neighbor && !neighbor.visited) {
                neighbors.push({cell: neighbor, dir: dir});
            }
        }
        
        if (neighbors.length > 0) {
            // Choisit un voisin aléatoire
            const {cell: next, dir} = neighbors[rng.nextInt(0, neighbors.length - 1)];
            
            // Supprime le mur entre les cellules
            current.walls[dir.wall] = false;
            next.walls[dir.opposite] = false;
            
            next.visited = true;
            stack.push(next);
        } else {
            stack.pop();
        }
    }
}

// Réduit la complexité du labyrinthe
function reduceMazeComplexity(mazeGrid, complexity) {
    // Supprime aléatoirement des murs pour créer des boucles
    const wallsToRemove = Math.floor(mazeGrid.length * (1 - complexity) * 0.5);
    
    for (let i = 0; i < wallsToRemove; i++) {
        const cell = mazeGrid[Math.floor(Math.random() * mazeGrid.length)];
        const walls = Object.keys(cell.walls).filter(w => cell.walls[w]);
        
        if (walls.length > 0) {
            const wallToRemove = walls[Math.floor(Math.random() * walls.length)];
            cell.walls[wallToRemove] = false;
        }
    }
}

// Applique le labyrinthe au donjon
function applyMazeToDungeon(mazeGrid) {
    for (let cell of mazeGrid) {
        // Place la cellule
        dungeon[cell.y][cell.x] = FLOOR;
        cellTypes[cell.y][cell.x] = CELL_TYPES.MAZE;
        
        // Place les murs/passages
        if (!cell.walls.n && cell.y > 0) {
            dungeon[cell.y - 1][cell.x] = FLOOR;
            cellTypes[cell.y - 1][cell.x] = CELL_TYPES.MAZE;
        }
        if (!cell.walls.s && cell.y < GRID_SIZE - 1) {
            dungeon[cell.y + 1][cell.x] = FLOOR;
            cellTypes[cell.y + 1][cell.x] = CELL_TYPES.MAZE;
        }
        if (!cell.walls.e && cell.x < GRID_SIZE - 1) {
            dungeon[cell.x + 1][cell.y] = FLOOR;
            cellTypes[cell.x + 1][cell.y] = CELL_TYPES.MAZE;
        }
        if (!cell.walls.w && cell.x > 0) {
            dungeon[cell.x - 1][cell.y] = FLOOR;
            cellTypes[cell.x - 1][cell.y] = CELL_TYPES.MAZE;
        }
    }
}

// Trouve les culs-de-sac
function findDeadEnds() {
    const deadEnds = [];
    
    for (let y = 1; y < GRID_SIZE - 1; y++) {
        for (let x = 1; x < GRID_SIZE - 1; x++) {
            if (dungeon[y][x] === FLOOR) {
                let walls = 0;
                const directions = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}];
                
                for (let dir of directions) {
                    if (dungeon[y + dir.y][x + dir.x] === WALL) {
                        walls++;
                    }
                }
                
                if (walls === 3) {
                    deadEnds.push({x, y});
                }
            }
        }
    }
    
    return deadEnds;
}

// Place le début et la fin
function placeStartAndEnd(rooms, rng) {
    if (rooms.length < 2) {
        // Fallback si pas assez de salles
        const floorCells = [];
        for (let y = 1; y < GRID_SIZE - 1; y++) {
            for (let x = 1; x < GRID_SIZE - 1; x++) {
                if (dungeon[y][x] === FLOOR) {
                    floorCells.push({x, y});
                }
            }
        }
        
        if (floorCells.length >= 2) {
            startPos = floorCells[0];
            endPos = floorCells[floorCells.length - 1];
        }
        return;
    }
    
    // Trouve les deux salles les plus éloignées
    let maxDistance = 0;
    let bestPair = {start: 0, end: 1};
    
    for (let i = 0; i < rooms.length; i++) {
        for (let j = i + 1; j < rooms.length; j++) {
            const dist = rooms[i].distanceTo(rooms[j]);
            if (dist > maxDistance) {
                maxDistance = dist;
                bestPair = {start: i, end: j};
            }
        }
    }
    
    startPos = {
        x: rooms[bestPair.start].centerX,
        y: rooms[bestPair.start].centerY
    };
    
    endPos = {
        x: rooms[bestPair.end].centerX,
        y: rooms[bestPair.end].centerY
    };
}

// Calcule la distance du chemin entre début et fin
function calculatePathDistance() {
    if (!startPos || !endPos) return 0;
    
    // Utilise A* pour trouver le chemin le plus court
    const path = findPath(startPos, endPos);
    return path ? path.length : 0;
}

// A* pathfinding
function findPath(start, end) {
    const openSet = [{...start, f: 0, g: 0, h: 0, parent: null}];
    const closedSet = new Set();
    
    while (openSet.length > 0) {
        // Trouve le nœud avec le plus petit f
        let current = openSet[0];
        let currentIndex = 0;
        
        for (let i = 1; i < openSet.length; i++) {
            if (openSet[i].f < current.f) {
                current = openSet[i];
                currentIndex = i;
            }
        }
        
        openSet.splice(currentIndex, 1);
        closedSet.add(`${current.x},${current.y}`);
        
        // Arrivé à destination
        if (current.x === end.x && current.y === end.y) {
            const path = [];
            let node = current;
            while (node) {
                path.push({x: node.x, y: node.y});
                node = node.parent;
            }
            return path.reverse();
        }
        
        // Explore les voisins
        const directions = [{x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}];
        for (let dir of directions) {
            const nx = current.x + dir.x;
            const ny = current.y + dir.y;
            
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE ||
                dungeon[ny][nx] === WALL || closedSet.has(`${nx},${ny}`)) {
                continue;
            }
            
            const g = current.g + 1;
            const h = Math.abs(nx - end.x) + Math.abs(ny - end.y);
            const f = g + h;
            
            // Vérifie si déjà dans openSet
            let inOpenSet = false;
            for (let node of openSet) {
                if (node.x === nx && node.y === ny) {
                    if (g < node.g) {
                        node.g = g;
                        node.f = f;
                        node.parent = current;
                    }
                    inOpenSet = true;
                    break;
                }
            }
            
            if (!inOpenSet) {
                openSet.push({x: nx, y: ny, f, g, h, parent: current});
            }
        }
    }
    
    return null;
}

// Analyse la qualité du donjon
function analyzeDungeonQuality() {
    const warnings = [];
    let score = 100;
    
    // Vérifie la distance entre début et fin
    if (pathDistance < 15) {
        warnings.push("Distance S→E trop courte");
        score -= 20;
    }
    
    // Vérifie le ratio d'espaces libres
    let floorCount = 0;
    for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
            if (dungeon[y][x] === FLOOR) floorCount++;
        }
    }
    const openRatio = (floorCount / (GRID_SIZE * GRID_SIZE)) * 100;
    
    if (openRatio < 25) {
        warnings.push("Trop dense (< 25% libre)");
        score -= 15;
    } else if (openRatio > 60) {
        warnings.push("Trop vide (> 60% libre)");
        score -= 15;
    }
    
    // Vérifie le nombre de culs-de-sac
    if (deadEndsList.length < 3) {
        warnings.push("Pas assez de culs-de-sac");
        score -= 10;
    } else if (deadEndsList.length > 15) {
        warnings.push("Trop de culs-de-sac");
        score -= 10;
    }
    
    // Vérifie les chemins alternatifs
    if (alternativePaths < 2) {
        warnings.push("Pas assez de chemins alternatifs");
        score -= 15;
    }
    
    return {score, warnings};
}

// Génère le donjon complet
function generateDungeon() {
    const seedValue = document.getElementById('seed').value;
    const rng = new Random(seedValue ? parseInt(seedValue) : null);
    
    // Initialise
    initializeDungeon();
    rooms = [];
    corridors = [];
    deadEndsList = [];
    
    // Récupère les paramètres
    const mode = DUNGEON_MODES[document.getElementById('dungeonMode').value];
    const density = parseInt(document.getElementById('roomDensity').value);
    const complexity = parseInt(document.getElementById('pathComplexity').value) / 100;
    
    // Génère les zones si mode mixte
    let zones = null;
    if (mode.name === 'Mixte') {
        zones = generateZones(rng);
    }
    
    // Place les salles principales
    const mainRooms = placeMainRooms(rng, mode, density, zones);
    
    // Place les salles secondaires
    const secondaryRooms = placeSecondaryRooms(rng, mode, mainRooms);
    
    // Combine toutes les salles
    rooms = [...mainRooms, ...secondaryRooms];
    
    // Connecte les salles
    connectRooms(rooms, rng, mode);
    
    // Génère les labyrinthes si activé
    if (document.getElementById('generateMazes').checked) {
        generateMazes(rng, complexity);
    }
    
    // Place le début et la fin
    placeStartAndEnd(mainRooms, rng);
    
    // Trouve les culs-de-sac
    deadEndsList = findDeadEnds();
    
    // Calcule les statistiques
    pathDistance = calculatePathDistance();
    
    // TODO: Calculer les chemins alternatifs
    alternativePaths = Math.floor(rooms.length / 3);
    
    // Met à jour l'affichage
    updateStats();
    drawDungeon();
}

// Met à jour les statistiques
function updateStats() {
    const mainRoomCount = rooms.filter(r => r.type === 'main').length;
    const secondaryRoomCount = rooms.filter(r => r.type === 'secondary').length;
    
    document.getElementById('mainRooms').textContent = mainRoomCount;
    document.getElementById('secondaryRooms').textContent = secondaryRoomCount;
    
    // Calcule le pourcentage d'espaces libres
    let floorCount = 0;
    for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
            if (dungeon[y][x] === FLOOR) floorCount++;
        }
    }
    const openRatio = Math.round((floorCount / (GRID_SIZE * GRID_SIZE)) * 100);
    document.getElementById('openSpaces').textContent = openRatio + '%';
    
    document.getElementById('deadEnds').textContent = deadEndsList.length;
    document.getElementById('pathDistance').textContent = pathDistance;
    document.getElementById('altPaths').textContent = alternativePaths;
}

// Dessine le donjon
function drawDungeon() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const showGrid = document.getElementById('showGrid').checked;
    const showRoomTypes = document.getElementById('showRoomTypes').checked;
    const markDeadEnds = document.getElementById('markDeadEnds').checked;
    
    // Dessine les cellules
    for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
            let color = '#222';
            
            if (dungeon[y][x] === FLOOR) {
                if (showRoomTypes) {
                    switch (cellTypes[y][x]) {
                        case CELL_TYPES.MAIN_ROOM:
                            color = '#e8e8e8';
                            break;
                        case CELL_TYPES.SECONDARY_ROOM:
                            color = '#b8b8b8';
                            break;
                        case CELL_TYPES.CORRIDOR:
                            color = '#888';
                            break;
                        case CELL_TYPES.MAZE:
                            color = '#666';
                            break;
                        case CELL_TYPES.SECRET:
                            color = '#a4f';
                            break;
                    }
                } else {
                    color = '#ccc';
                }
            }
            
            ctx.fillStyle = color;
            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - (showGrid ? 1 : 0), CELL_SIZE - (showGrid ? 1 : 0));
        }
    }
    
    // Dessine les culs-de-sac
    if (markDeadEnds) {
        ctx.fillStyle = '#fa0';
        for (let deadEnd of deadEndsList) {
            if ((!startPos || deadEnd.x !== startPos.x || deadEnd.y !== startPos.y) &&
                (!endPos || deadEnd.x !== endPos.x || deadEnd.y !== endPos.y)) {
                ctx.fillRect(deadEnd.x * CELL_SIZE + 2, deadEnd.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            }
        }
    }
    
    // Dessine le début
    if (startPos) {
        ctx.fillStyle = '#4a4';
        ctx.fillRect(startPos.x * CELL_SIZE, startPos.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('S', startPos.x * CELL_SIZE + CELL_SIZE/2, startPos.y * CELL_SIZE + CELL_SIZE/2);
    }
    
    // Dessine la fin
    if (endPos) {
        ctx.fillStyle = '#f44';
        ctx.fillRect(endPos.x * CELL_SIZE, endPos.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('E', endPos.x * CELL_SIZE + CELL_SIZE/2, endPos.y * CELL_SIZE + CELL_SIZE/2);
    }
}

// Exporte le donjon en JSON
function exportDungeon() {
    const data = {
        grid: dungeon,
        metadata: {
            gridSize: GRID_SIZE,
            mode: document.getElementById('dungeonMode').value,
            rooms: rooms.map(r => ({
                x: r.x,
                y: r.y,
                width: r.width,
                height: r.height,
                type: r.type
            })),
            start: startPos,
            end: endPos,
            deadEnds: deadEndsList,
            pathDistance: pathDistance,
            seed: document.getElementById('seed').value || 'random',
            quality: analyzeDungeonQuality()
        }
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dungeon_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

// Event listeners
document.getElementById('generateBtn').addEventListener('click', generateDungeon);
document.getElementById('analyzeBtn').addEventListener('click', function() {
    const {score, warnings} = analyzeDungeonQuality();
    
    const scoreElement = document.getElementById('qualityScore');
    scoreElement.textContent = `${score}/100`;
    scoreElement.style.color = score >= 80 ? '#4a4' : score >= 60 ? '#fa0' : '#f44';
    
    const warningsElement = document.getElementById('qualityWarnings');
    if (warnings.length > 0) {
        warningsElement.innerHTML = warnings.map(w => `<div class="warning">• ${w}</div>`).join('');
    } else {
        warningsElement.innerHTML = '<div style="color: #4a4;">✓ Aucun problème détecté</div>';
    }
});
document.getElementById('exportBtn').addEventListener('click', exportDungeon);

// Mode selector
document.getElementById('dungeonMode').addEventListener('change', function() {
    const mode = DUNGEON_MODES[this.value];
    document.getElementById('modeDescription').textContent = mode.description;
});

// Sliders
document.getElementById('dungeonSize').addEventListener('input', function() {
    const sizes = ['Petit', 'Moyen', 'Grand'];
    document.getElementById('dungeonSizeValue').textContent = sizes[this.value - 1];
});

document.getElementById('roomDensity').addEventListener('input', function() {
    document.getElementById('roomDensityValue').textContent = this.value + '%';
});

document.getElementById('pathComplexity').addEventListener('input', function() {
    document.getElementById('pathComplexityValue').textContent = this.value + '%';
});

// Checkboxes
document.getElementById('markDeadEnds').addEventListener('change', function() {
    document.getElementById('deadEndLegend').style.display = this.checked ? 'flex' : 'none';
    drawDungeon();
});

document.getElementById('placeSecrets').addEventListener('change', function() {
    document.getElementById('secretLegend').style.display = this.checked ? 'flex' : 'none';
});

document.getElementById('showGrid').addEventListener('change', drawDungeon);
document.getElementById('showRoomTypes').addEventListener('change', drawDungeon);

// Génère un donjon initial
generateDungeon();
    </script>
</body>
</html>