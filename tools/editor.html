<!DOCTYPE html>
<html>
  <head>
    <title>Oasis - Map Editor</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
        background-color: #f1f1f1;
        font-family: Arial, sans-serif;
      }

      .header {
        background-color: #333;
        color: #fff;
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .header h1 {
        margin: 0;
        font-size: 24px;
      }

      .tabs {
        display: flex;
      }

      .tabs button {
        background-color: #444;
        color: #fff;
        border: none;
        padding: 10px 20px;
        cursor: pointer;
        margin-right: 2px;
        font-size: 14px;
      }

      .tabs button.active {
        background-color: #666;
      }

      .tile-item {
        padding: 10px;
        margin: 5px 0;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        cursor: pointer;
      }
      
      .sprite-item {
        padding: 10px;
        margin: 5px 0;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        cursor: pointer;
      }
      
      .tile-item.active,
      .sprite-item.active {
        background-color: #ffe066; /* Fond jaune clair pour l'élément sélectionné */
        border: 2px solid #ffcc00; /* Bordure plus épaisse pour indiquer la sélection */
      }
      
      
      .container {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      .palette {
        width: 20%;
        padding: 10px;
        background-color: #fff;
        border-right: 1px solid #999;
        overflow-y: auto;
      }

      .palette h2 {
        margin-top: 0;
        font-size: 18px;
      }

      .palette .palette-section {
        margin-bottom: 20px;
      }

      .palette button,
      .palette select,
      .palette input,
      .palette textarea {
        width: 100%;
        margin-bottom: 10px;
        padding: 5px;
        font-size: 14px;
      }

      /* Hide the custom sprite form by default */
      #custom-sprite-form {
        display: none;
      }

      .editor-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      .map-container,
      .sprite-map-container,
      .teleport-editor-container {
        flex: 1;
        display: none;
        position: relative;
      }

      .map-container.active,
      .sprite-map-container.active,
      .teleport-editor-container.active {
        display: block;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(24, 30px);
        grid-template-rows: repeat(24, 30px);
        gap: 1px;
        background-color: #999;
        padding: 10px;
        overflow: auto;
        max-height: 80vh;
      }

      .tile {
        width: 30px;
        height: 30px;
        background-color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        border: 1px solid #ccc; /* Ajouter une bordure légère */
      }
      
      .tile.selected {
        outline: 2px solid #ff0; /* Mettre en évidence la tuile sélectionnée */
      }

      .sprite {
        position: absolute;
        top: 0;
        left: 0;
        width: 30px;
        height: 30px;
        pointer-events: none;
        transform-origin: center;
      }

      .sprite img {
        width: 100%;
        height: 100%;
        transform: rotate(0deg);
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background-color: #fefefe;
        padding: 20px;
        border: 1px solid #888;
        width: 400px;
        border-radius: 5px;
      }

      .modal-content h2 {
        margin-top: 0;
      }

      .modal-content label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      .modal-content input,
      .modal-content select,
      .modal-content textarea {
        width: 100%;
        padding: 5px;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .modal-content button {
        padding: 10px 15px;
        font-size: 14px;
        margin-right: 10px;
        cursor: pointer;
      }

      .export-area {
        padding: 10px;
        background-color: #fff;
        border-top: 1px solid #999;
        display: none;
        flex-direction: column;
      }

      .export-area.active {
        display: block;
        /* Shown when active */
      }

      .export-area textarea {
        width: 100%;
        height: 100px;
        margin-bottom: 10px;
        resize: none;
      }

      .coordinates {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 5px 10px;
        border-radius: 3px;
        font-size: 14px;
      }

      .custom-sprite-form, .teleport-form {
        padding: 20px;
        border: 1px solid #ddd;
        background-color: #f9f9f9;
        max-width: 600px;
        margin: 0 auto;
        max-height: auto; /* Limite la hauteur visible de l'onglet */
        overflow-y: auto;  /* Active le scrolling vertical */
      }
      
      .custom-sprite-form h2, .teleport-form h2 {
        margin-bottom: 20px;
      }
      
      .custom-sprite-form label, .teleport-form label {
        font-weight: bold;
        margin-top: 10px;
      }
      
      .custom-sprite-form input[type="text"], 
      .custom-sprite-form input[type="number"], 
      .teleport-form input[type="text"], 
      .teleport-form input[type="number"] {
        width: 100%;
        padding: 8px;
        margin: 5px 0 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      
      .custom-sprite-form button, .teleport-form button {
        background-color: #28a745;
        color: white;
        border: none;
        padding: 10px 20px;
        text-align: center;
        font-size: 16px;
        cursor: pointer;
        display: inline-block;
      }
      
      .custom-sprite-form button:hover, .teleport-form button:hover {
        background-color: #218838;
      }
      
      #teleporter-list {
        margin-top: 20px;
        border-top: 1px solid #ccc;
        padding-top: 20px;
      }
      
      #teleporter-list-items {
        list-style: none;
        padding-left: 0;
      }
      
      #teleporter-list-items li {
        padding: 10px;
        background-color: #f0f0f0;
        margin-bottom: 10px;
        border-radius: 4px;
      }
      
      #teleport-select {
        width: 100%;
        padding: 8px;
        margin-top: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .sprite-map-container {
        position: relative;
        display: block; /* Toujours visible quand on est sur l'onglet des sprites */
      }
      
      #map-grid {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1; /* Grille de la carte en arrière-plan */
        opacity: 0.6; /* Transparence pour voir les murs en gris */
      }
      
      #sprite-grid {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2; /* Grille des sprites au-dessus */
      }
      
      
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Oasis - Map Editor</h1>
      <div class="tabs">
        <button class="tab-button active" data-tab="map">Carte Principale</button>
        <button class="tab-button" data-tab="sprites">Sprites</button>
        <button class="tab-button" data-tab="custom-sprites">Custom Sprites</button>
        <button class="tab-button" data-tab="teleporters">Téléporteurs</button>
        <button class="tab-button" data-tab="export">Exporter</button>
      </div>
    </div>
    <div class="container">
      <div class="palette" id="palette">
        <!-- Dynamic Palette Content -->
      </div>
      <div class="editor-area">
        <!-- Map Container -->
        <div class="map-container active" id="map-container">
          <div class="grid" id="map-grid"></div>
        </div>
        <!-- Sprite Map Container -->
        <div class="sprite-map-container" id="sprite-map-container">
          <div class="grid" id="map-grid"></div>
          <div class="grid" id="sprite-grid"></div>
        </div>
        
        <!--CUSTOM SPRITES TAB-->
        <div class="custom-sprite-form" id="custom-sprite-form" style="display:none;">
          <h2>Créer un Sprite Personnalisé</h2>
          <label for="sprite-name">Nom du Sprite:</label>
          <input type="text" id="sprite-name" placeholder="Nom du Sprite">
          <!--
          <label for="sprite-id">ID du Sprite:</label>
          <input type="number" id="sprite-id" placeholder="ID du Sprite">
          <label for="sprite-x">Position X:</label>
          <input type="number" id="sprite-x" placeholder="Position X" value="0">
          <label for="sprite-y">Position Y:</label>
          <input type="number" id="sprite-y" placeholder="Position Y" value="0">
          <label for="sprite-z">Position Z:</label>
          <input type="number" id="sprite-z" placeholder="Position Z" value="0">
          <label for="sprite-w">Largeur (w):</label>
          <input type="number" id="sprite-w" placeholder="Largeur" value="128">
          <label for="sprite-h">Hauteur (h):</label>
          <input type="number" id="sprite-h" placeholder="Hauteur" value="128">
          <label for="sprite-ang">Angle (ang):</label>
          <input type="number" id="sprite-ang" placeholder="Angle" value="0">
          -->
          <label for="sprite-type">Type de Sprite:</label>
          <input type="number" id="sprite-type" placeholder="Type de Sprite" value="0">
        </br>
          <label for="sprite-texture">Texture du Sprite:</label>
          <input type="text" id="sprite-texture" placeholder="Texture du Sprite" value="">
        </br>
          <label for="sprite-is-blocking">Bloquant?</label>
          <input type="checkbox" id="sprite-is-blocking" checked>
        </br>
          <label for="sprite-attackable">Attaquable?</label>
          <input type="checkbox" id="sprite-attackable">
        </br>
          <label for="sprite-turn">Peut tourner?</label>
          <input type="checkbox" id="sprite-turn" checked>
        </br>
        </br>

          <label for="sprite-hp">Points de Vie (hp):</label>
          <input type="number" id="sprite-hp" placeholder="HP" value="1">
          <label for="sprite-dmg">Dégâts (dmg):</label>
          <input type="number" id="sprite-dmg" placeholder="Dégâts" value="1">
        <!--
          <label for="sprite-animation-progress">Progression d'Animation:</label>
          <input type="number" id="sprite-animation-progress" placeholder="Progression d'Animation" value="0">
        --> 
          <label for="sprite-face">Face du Sprite:</label>
          <input type="text" id="sprite-face" placeholder="Face du Sprite" value="">
          <label for="sprite-talk">Dialogue (Array):</label>
          <input type="text" id="sprite-talk" placeholder="Dialogue séparé par des virgules" value="">
          <label for="sprite-sell">Objets à vendre (Array):</label>
          <input type="text" id="sprite-sell" placeholder="Ventes séparées par des virgules" value="">
          <button onclick="createCustomSprite()">Créer le Sprite</button>
        </div>
        <!-- Teleporter Editor Container -->
        <div class="teleport-form" id="teleport-form" style="display:none;">
          <h2>Ajouter / Modifier un Téléporteur</h2>
          <label for="teleport-start-x">Coordonnée de départ X:</label>
          <input type="number" id="teleport-start-x" placeholder="X de départ" value="0">
          <label for="teleport-start-y">Coordonnée de départ Y:</label>
          <input type="number" id="teleport-start-y" placeholder="Y de départ" value="0">
          <label for="teleport-start-direction">Direction de départ:</label>
          <input type="text" id="teleport-start-direction" placeholder="Direction" value="nord">
          <label for="teleport-start-blocking">Blocage de départ:</label>
          <input type="checkbox" id="teleport-start-blocking">
          <label for="teleport-start-map">Carte de départ:</label>
          <input type="number" id="teleport-start-map" value="1">
          <label for="teleport-start-layer">Couche de départ:</label>
          <input type="number" id="teleport-start-layer" value="1">
          <label for="teleport-start-zone">Zone de départ:</label>
          <input type="number" id="teleport-start-zone" value="1">
          <label for="teleport-start-message">Message de départ:</label>
          <input type="text" id="teleport-start-message" value="">
          <label for="teleport-end-x">Coordonnée de destination X:</label>
          <input type="number" id="teleport-end-x" placeholder="X de destination" value="0">
          <label for="teleport-end-y">Coordonnée de destination Y:</label>
          <input type="number" id="teleport-end-y" placeholder="Y de destination" value="0">
          <label for="teleport-end-direction">Direction de destination:</label>
          <input type="text" id="teleport-end-direction" placeholder="Direction" value="sud">
          <label for="teleport-end-blocking">Blocage de destination:</label>
          <input type="checkbox" id="teleport-end-blocking">
          <label for="teleport-end-map">Carte de destination:</label>
          <input type="number" id="teleport-end-map" value="1">
          <label for="teleport-end-layer">Couche de destination:</label>
          <input type="number" id="teleport-end-layer" value="1">
          <label for="teleport-end-zone">Zone de destination:</label>
          <input type="number" id="teleport-end-zone" value="1">
          <label for="teleport-end-message">Message de destination:</label>
          <input type="text" id="teleport-end-message" value="">
          <button onclick="addTeleporterPair()">Ajouter Téléporteur</button>
          <div id="teleporter-list">
            <h3>Liste des Téléporteurs</h3>
            <ul id="teleporter-list-items"></ul>
            <select id="teleport-select"></select>
            <div id="teleport-details" style="display:none;">
              <!-- Autres champs pour les détails du téléporteur -->
            </div>
          </div>
        </div>
        <!-- Export Container -->
        <!-- Export Area -->
        <div class="export-area" id="export-area">
          <!--
        
        <button onclick="exportAll()">Exporter en JSON</button><textarea id="export-output" readonly></textarea>
      -->
          <H2>Save maps</H2>
          <button onclick="saveAllMaps()">Sauvegarder Toutes les Cartes</button>
          <input type="file" id="fileInput" style="display:none;" onchange="loadAllMaps(event)">
          <button onclick="document.getElementById('fileInput').click()">Charger Toutes les Cartes</button>
          <h2>Previous/Next map</h2>
          <div id="current-map-label">Carte Actuelle: 1</div>
          <button onclick="previousMap()">Carte Précédente</button>
          <button onclick="nextMap()">Carte Suivante</button>
          <br>
          <br>
          <!--
          <button onclick="resetCurrentMap()">Réinitialiser la Carte</button>
          -->
        </div>
        <!-- Coordinates Display -->
        <div class="coordinates" id="coordinates">Coordonnées : x: -, y: -</div>
      </div>
    </div>
    <!-- Sprite Modal -->
    <div id="sprite-modal" class="modal">
      <div class="modal-content">
        <h2>Créer/Modifier Sprite</h2>
        <label for="sprite-id">ID Unique :</label>
        <input type="text" id="sprite-id" readonly>
        <label for="sprite-type">Type de Sprite :</label>
        <select id="sprite-type">
          <option value="PNJ">PNJ</option>
          <option value="objet">Objet</option>
          <option value="ennemi">Ennemi</option>
        </select>
        <label for="sprite-name">Nom :</label>
        <input type="text" id="sprite-name">
        <label for="sprite-w">Largeur (w) :</label>
        <input type="number" id="sprite-w" min="1" max="10">
        <label for="sprite-h">Hauteur (h) :</label>
        <input type="number" id="sprite-h" min="1" max="10">
        <label for="sprite-angle">Angle de Rotation :</label>
        <input type="number" id="sprite-angle" min="0" max="360">
        <label for="sprite-texture">Texture :</label>
        <input type="text" id="sprite-texture" placeholder="URL de la texture">
        <label for="sprite-isBlocking">Bloquant :</label>
        <input type="checkbox" id="sprite-isBlocking">
        <label for="sprite-attackable">Attaquable :</label>
        <input type="checkbox" id="sprite-attackable">
        <label for="sprite-hp">HP :</label>
        <input type="number" id="sprite-hp" min="0">
        <label for="sprite-dmg">Dégâts :</label>
        <input type="number" id="sprite-dmg" min="0">
        <label for="sprite-turn">Tour :</label>
        <input type="number" id="sprite-turn" min="0">
        <label for="sprite-interaction">Interaction :</label>
        <textarea id="sprite-interaction" placeholder='Format: {"spriteTalk": "Hello"}'></textarea>
        <label for="sprite-layer">Couche (Layer) :</label>
        <select id="sprite-layer">
          <option value="0">Arrière-plan</option>
          <option value="1">Premier plan</option>
        </select>
        <label for="sprite-animations">Animations (Séparer par des virgules) :</label>
        <input type="text" id="sprite-animations" placeholder="frame1.png,frame2.png,...">
        <button onclick="saveSprite()">Enregistrer</button>
        <button onclick="closeSpriteModal()">Annuler</button>
      </div>
    </div>
    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal">
      <div class="modal-content">
        <p>Êtes-vous sûr de vouloir réinitialiser la carte ? Cette action est irréversible.</p>
        <button onclick="confirmResetMap()">Oui</button>
        <button onclick="cancelResetMap()">Non</button>
      </div>
    </div>
    <script>
      // Global Variables
      const mapGrid = document.getElementById('map-grid');
      const spriteGrid = document.getElementById('sprite-grid');
      const palette = document.getElementById('palette');
      const coordinatesDisplay = document.getElementById('coordinates');
      const spriteModal = document.getElementById('sprite-modal');
      const exportOutput = document.getElementById('export-output');
      const teleportSelect = document.getElementById('teleport-select');
      let currentTab = 'map';
      let selectedTile = null;
      let selectedSprite = null;
      let worldMap = [];
      let worldSpriteMap = [];
      let sprites = [];
      let teleporters = [];
      let spriteIdCounter = 1;

      // Define the basic sprites     
      const basicSprites = [
  { id: 1, spriteName: "Sprite 1", spriteTexture: 1, spriteFace: "face1", spriteTalk: [], spriteSell: [], hp: 5, dmg: 2 },
  { id: 2, spriteName: "Sprite 2", spriteTexture: 2, spriteFace: "face2", spriteTalk: [], spriteSell: [], hp: 4, dmg: 1 },
  { id: 3, spriteName: "Sprite 3", spriteTexture: 3, spriteFace: "face3", spriteTalk: [], spriteSell: [], hp: 6, dmg: 3 },
  { id: 4, spriteName: "Sprite 4", spriteTexture: 4, spriteFace: "face4", spriteTalk: [], spriteSell: [], hp: 7, dmg: 4 },
  { id: 5, spriteName: "Sprite 5", spriteTexture: 5, spriteFace: "face5", spriteTalk: [], spriteSell: [], hp: 3, dmg: 2 },
  { id: 6, spriteName: "Sprite 6", spriteTexture: 6, spriteFace: "face6", spriteTalk: [], spriteSell: [], hp: 5, dmg: 3 },
  { id: 7, spriteName: "Sprite 7", spriteTexture: 7, spriteFace: "face7", spriteTalk: [], spriteSell: [], hp: 4, dmg: 2 },
  { id: 8, spriteName: "Sprite 8", spriteTexture: 8, spriteFace: "face8", spriteTalk: [], spriteSell: [], hp: 6, dmg: 3 },
  { id: 9, spriteName: "Sprite 9", spriteTexture: 9, spriteFace: "face9", spriteTalk: [], spriteSell: [], hp: 5, dmg: 2 },
  { id: 10, spriteName: "Sprite 10", spriteTexture: 10, spriteFace: "face10", spriteTalk: [], spriteSell: [], hp: 7, dmg: 4 },
  { id: 11, spriteName: "Sprite 11", spriteTexture: 11, spriteFace: "face11", spriteTalk: [], spriteSell: [], hp: 3, dmg: 1 },
  { id: 12, spriteName: "Sprite 12", spriteTexture: 12, spriteFace: "face12", spriteTalk: [], spriteSell: [], hp: 6, dmg: 2 },
  { id: 13, spriteName: "Sprite 13", spriteTexture: 13, spriteFace: "face13", spriteTalk: [], spriteSell: [], hp: 4, dmg: 3 },
  { id: 14, spriteName: "Sprite 14", spriteTexture: 14, spriteFace: "face14", spriteTalk: [], spriteSell: [], hp: 5, dmg: 2 },
  { id: 15, spriteName: "Sprite 15", spriteTexture: 15, spriteFace: "face15", spriteTalk: [], spriteSell: [], hp: 7, dmg: 4 },
  { id: 16, spriteName: "Sprite 16", spriteTexture: 16, spriteFace: "face16", spriteTalk: [], spriteSell: [], hp: 5, dmg: 3 },
  { id: 17, spriteName: "Sprite 17", spriteTexture: 17, spriteFace: "face17", spriteTalk: [], spriteSell: [], hp: 4, dmg: 2 },
  { id: 18, spriteName: "Sprite 18", spriteTexture: 18, spriteFace: "face18", spriteTalk: [], spriteSell: [], hp: 6, dmg: 3 },
  { id: 19, spriteName: "Sprite 19", spriteTexture: 19, spriteFace: "face19", spriteTalk: [], spriteSell: [], hp: 4, dmg: 1 },
  { id: 20, spriteName: "Sprite 20", spriteTexture: 20, spriteFace: "face20", spriteTalk: [], spriteSell: [], hp: 7, dmg: 4 }
];

const basicTiles = [
  { id: 0, tileName: "Vide", description: "Aucune tuile (0)" },
  { id: 1, tileName: "Herbe", description: "Tuile de base (1)" },
  { id: 2, tileName: "Sable", description: "Tuile de base (2)" },
  { id: 3, tileName: "Eau", description: "Tuile de base (3)" },
  { id: 4, tileName: "Roche", description: "Tuile de base (4)" },
  { id: 5, tileName: "Route", description: "Tuile de base (5)" },
  { id: 6, tileName: "Mur", description: "Tuile de base (6)" },
  { id: 7, tileName: "Escalier", description: "Tuile de base (7)" },
  { id: 8, tileName: "Plancher", description: "Tuile de base (8)" },
  { id: 9, tileName: "Toit", description: "Tuile de base (9)" }
];


      let eventA = []; // Empty list for source teleporters
      let eventB = []; // Empty list for destination teleporters
      let maps = []; // Initialize the maps array
      let currentMapIndex = 0;

      function loadMap(mapIndex) {
        const mapData = maps[mapIndex];
        // Load map data
        worldMap = mapData.map;
        // Load the correct list of sprites for this specific map
        sprites = mapData.sprites;
        // Load the sprite grid for this map
        worldSpriteMap = mapData.worldSpriteMap;
        // Load teleporters
        eventA = mapData.eventA;
        eventB = mapData.eventB;
        // Load player start
        playerStart = mapData.playerStart;
        // Re-render the map, sprites, and teleporters immediately
        requestAnimationFrame(() => {
          updateMapGrid();
          updateSpriteGrid(); // Ensure the sprite grid is rendered immediately
          updateTeleporterList();
        });
        // Update the current map label
        document.getElementById('current-map-label').textContent = `Carte Actuelle: ${mapData.mapID}`;
      }

      function createNewMap() {
        // Sauvegarder la carte actuelle avant de créer une nouvelle
        saveCurrentMap();
      
        // Création de la nouvelle carte
        const newMapID = maps.length + 1;
        const mapSize = 24;
        const borderValue = 1;
        const defaultTile = 0;
        const newMap = {
          mapID: newMapID,
          map: Array.from({ length: mapSize }, (_, rowIndex) => {
            return Array.from({ length: mapSize }, (_, colIndex) => {
              if (rowIndex === 0 || rowIndex === mapSize - 1 || colIndex === 0 || colIndex === mapSize - 1) {
                return borderValue;
              } else {
                return defaultTile;
              }
            });
          }),
          sprites: [],
          worldSpriteMap: Array.from({ length: mapSize }, () => Array(mapSize).fill(0)),
          eventA: [],
          eventB: [],
          playerStart: {
            X: 0,
            Y: 0,
            Orientation: 0,
            ceilingRender: false,
            ceilingHeight: 2,
            ceilingTexture: 1,
            floorTexture: 1
          }
        };
        maps.push(newMap);
        currentMapIndex = maps.length - 1;
        loadMap(currentMapIndex);
      }
      
      function saveCurrentMap() {
        if (maps[currentMapIndex]) {
          maps[currentMapIndex].map = worldMap;
          maps[currentMapIndex].sprites = sprites;
          maps[currentMapIndex].worldSpriteMap = worldSpriteMap;
          maps[currentMapIndex].eventA = eventA;
          maps[currentMapIndex].eventB = eventB;
        }
      }
      
      function nextMap() {
        // Save the current map's sprites before switching maps
        maps[currentMapIndex].sprites = sprites;
        if (currentMapIndex < maps.length - 1) {
          currentMapIndex++;
          loadMap(currentMapIndex);
        } else {
          const createNew = confirm("Il n'y a pas de carte suivante. Voulez-vous en créer une nouvelle ?");
          if (createNew) {
            createNewMap();
          }
        }
      }

      function previousMap() {
        // Save the current map's sprites before switching maps
        maps[currentMapIndex].sprites = sprites;
        if (currentMapIndex > 0) {
          currentMapIndex--;
          loadMap(currentMapIndex);
        }
      }

      function setupTeleporterSelect() {
        const teleportSelect = document.getElementById('teleport-select');
        if (!teleportSelect) {
          console.error('Element teleport-select not found.');
          return;
        }
        teleportSelect.innerHTML = ' < option value = "0" > Sélectionnez un téléporteur < /option>';
        teleporters.forEach((tp, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = tp.name || `Téléporteur ${index + 1}`;
          teleportSelect.appendChild(option);
        });
        teleportSelect.addEventListener('change', () => {
          const index = teleportSelect.value;
          if (index === '') {
            document.getElementById('teleport-details').style.display = 'none';
            return;
          }
          const tp = teleporters[index];
          document.getElementById('teleport-name').value = tp.name;
          document.getElementById('teleport-id').value = tp.id;
          document.getElementById('teleport-start-x').value = tp.startX;
          document.getElementById('teleport-start-y').value = tp.startY;
          document.getElementById('teleport-end-x').value = tp.endX;
          document.getElementById('teleport-end-y').value = tp.endY;
          document.getElementById('teleport-rotation').value = tp.rotation;
          document.getElementById('teleport-context').value = tp.context;
          document.getElementById('teleport-details').style.display = 'block';
        });
      }
      window.onload = function() {
        initialize(); // Call initialize when the DOM is fully loaded
      };
      // Add a new teleporter pair (eventA and eventB)
      function addTeleporterPair() {
        const startX = parseInt(document.getElementById('teleport-start-x').value);
        const startY = parseInt(document.getElementById('teleport-start-y').value);
        const startDirection = document.getElementById('teleport-start-direction').value;
        const startBlocking = document.getElementById('teleport-start-blocking').checked;
        const startMap = parseInt(document.getElementById('teleport-start-map').value);
        const startLayer = parseInt(document.getElementById('teleport-start-layer').value);
        const startZone = parseInt(document.getElementById('teleport-start-zone').value);
        const startMessage = document.getElementById('teleport-start-message').value;
        const endX = parseInt(document.getElementById('teleport-end-x').value);
        const endY = parseInt(document.getElementById('teleport-end-y').value);
        const endDirection = document.getElementById('teleport-end-direction').value;
        const endBlocking = document.getElementById('teleport-end-blocking').checked;
        const endMap = parseInt(document.getElementById('teleport-end-map').value);
        const endLayer = parseInt(document.getElementById('teleport-end-layer').value);
        const endZone = parseInt(document.getElementById('teleport-end-zone').value);
        const endMessage = document.getElementById('teleport-end-message').value;
        // Add to eventA and eventB lists
        eventA.push([startX, startY, startDirection, startBlocking, startMap, startLayer, startZone, startMessage]);
        eventB.push([endX, endY, endDirection, endBlocking, endMap, endLayer, endZone, endMessage]);
        // Update the list of teleporters
        updateTeleporterList();
        resetTeleporterForm();
      }
      // Update the list of teleporters in the UI
      function updateTeleporterList() {
        const teleporterList = document.getElementById('teleporter-list-items');
        teleporterList.innerHTML = ''; // Clear existing list
        eventA.forEach((teleporter, index) => {
          const listItem = document.createElement('li');
          const [startX, startY] = teleporter;
          const [endX, endY] = eventB[index];
          listItem.textContent = `A: (${startX}, ${startY}) -> B: (${endX}, ${endY})`;
          listItem.onclick = () => selectTeleporterPair(index);
          const deleteButton = document.createElement('button');
          deleteButton.textContent = 'Supprimer';
          deleteButton.onclick = (event) => {
            event.stopPropagation(); // Prevent selecting the teleporter when deleting
            deleteTeleporterPair(index);
          };
          listItem.appendChild(deleteButton);
          teleporterList.appendChild(listItem);
        });
      }
      // Select a teleporter for modification
      function selectTeleporterPair(index) {
        const [startX, startY, startDirection, startBlocking, startMap, startLayer, startZone, startMessage] = eventA[index];
        const [endX, endY, endDirection, endBlocking, endMap, endLayer, endZone, endMessage] = eventB[index];
        // Fill the form with the selected teleporter's values
        document.getElementById('teleport-start-x').value = startX;
        document.getElementById('teleport-start-y').value = startY;
        document.getElementById('teleport-start-direction').value = startDirection;
        document.getElementById('teleport-start-blocking').checked = startBlocking;
        document.getElementById('teleport-start-map').value = startMap;
        document.getElementById('teleport-start-layer').value = startLayer;
        document.getElementById('teleport-start-zone').value = startZone;
        document.getElementById('teleport-start-message').value = startMessage;
        document.getElementById('teleport-end-x').value = endX;
        document.getElementById('teleport-end-y').value = endY;
        document.getElementById('teleport-end-direction').value = endDirection;
        document.getElementById('teleport-end-blocking').checked = endBlocking;
        document.getElementById('teleport-end-map').value = endMap;
        document.getElementById('teleport-end-layer').value = endLayer;
        document.getElementById('teleport-end-zone').value = endZone;
        document.getElementById('teleport-end-message').value = endMessage;
      }
      // Delete a teleporter pair
      function deleteTeleporterPair(index) {
        eventA.splice(index, 1); // Remove from eventA
        eventB.splice(index, 1); // Remove from eventB
        updateTeleporterList(); // Refresh the list
      }
      // Reset the teleporter form after adding or modifying a teleporter
      function resetTeleporterForm() {
        document.getElementById('teleport-start-x').value = '0';
        document.getElementById('teleport-start-y').value = '0';
        document.getElementById('teleport-end-x').value = '0';
        document.getElementById('teleport-end-y').value = '0';
        document.getElementById('teleport-start-direction').value = 'nord';
        document.getElementById('teleport-end-direction').value = 'sud';
        document.getElementById('teleport-start-blocking').checked = false;
        document.getElementById('teleport-end-blocking').checked = false;
        document.getElementById('teleport-start-map').value = '1';
        document.getElementById('teleport-start-layer').value = '1';
        document.getElementById('teleport-start-zone').value = '1';
        document.getElementById('teleport-end-map').value = '1';
        document.getElementById('teleport-end-layer').value = '1';
        document.getElementById('teleport-end-zone').value = '1';
        document.getElementById('teleport-start-message').value = '';
        document.getElementById('teleport-end-message').value = '';
      }
      // Initialize Maps
      function generateWorldMap(rows, cols, borderValue, innerValue) {
        const map = [];
        for (let i = 0; i < rows; i++) {
          const row = [];
          for (let j = 0; j < cols; j++) {
            if (i === 0 || i === rows - 1 || j === 0 || j === cols - 1) {
              row.push(borderValue);
            } else {
              row.push(innerValue);
            }
          }
          map.push(row);
        }
        return map;
      }

      function initialize() {
        // Initialisation des grilles et autres composants
        worldMap = generateWorldMap(24, 24, 1, 0);
        worldSpriteMap = generateWorldMap(24, 24, 'x', 0);
        
        createGrid(mapGrid, worldMap, 'map');
        createGrid(spriteGrid, worldSpriteMap, 'sprites');
        
        // Par défaut, seules les grilles de la carte principale sont visibles
        document.getElementById('map-container').style.display = 'block';
        document.getElementById('sprite-map-container').style.display = 'none';
        
        updateMapGrid();
        setupPalette();
        setupTabs();
        setupTeleporterSelect();
      }
      

      // Create Grid
      function createGrid(container, map, type) {
        container.innerHTML = '';
        container.style.gridTemplateColumns = `repeat(${map[0].length}, 30px)`;
        container.style.gridTemplateRows = `repeat(${map.length}, 30px)`;
        for (let y = 0; y < map.length; y++) {
          for (let x = 0; x < map[y].length; x++) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.setAttribute('data-x', x);
            tile.setAttribute('data-y', y);
            tile.addEventListener('click', () => onTileClick(x, y, type));
            container.appendChild(tile);
          }
        }
      }

      function updateMapGrid() {
        const tiles = mapGrid.querySelectorAll('.tile');
        tiles.forEach(tile => {
          const x = parseInt(tile.getAttribute('data-x'));
          const y = parseInt(tile.getAttribute('data-y'));
          const tileValue = worldMap[y][x];
          // Clear previous content
          tile.innerHTML = '';
          // Vérifier la valeur de la tuile et ajuster le style
          if (tileValue === 1) {
            tile.style.backgroundColor = '#000'; // Wall (black background for walls)
            tile.textContent = '1'; // Show the wall number
            tile.style.color = '#fff'; // White text for visibility
          } else if (tileValue === 0) {
            tile.style.backgroundColor = '#fff'; // Empty space (white background)
          } else {
            // Si la tuile est différente de 0, affiche son numéro
            tile.style.backgroundColor = '#ccc'; // Grey for other terrain types
            tile.textContent = tileValue; // Display the tile number
            tile.style.color = '#000'; // Black text for visibility
          }
        });
        // Force immediate re-render to ensure the tiles are displayed correctly
        requestAnimationFrame(() => {
          mapGrid.classList.remove('hidden');
        });
      }



function updateSpriteGrid() {
  const tiles = spriteGrid.querySelectorAll('.tile');
  tiles.forEach(tile => {
    const x = parseInt(tile.getAttribute('data-x'));
    const y = parseInt(tile.getAttribute('data-y'));
    const tileValue = worldMap[y][x];
    const spriteValue = worldSpriteMap[y][x];

    // Efface le contenu précédent de la tuile des sprites uniquement
    tile.innerHTML = '';

    // Les murs sont toujours visibles depuis la grille de la carte
    if (tileValue === 1) {
      // Grille des sprites ne doit pas effacer le mur de la carte
      tile.style.backgroundColor = 'rgba(128, 128, 128, 0.6)'; // Gris semi-transparent pour les murs
    } else if (tileValue === 0) {
      // Les cases inutilisées apparaissent en blanc
      tile.style.backgroundColor = '#fff';
    }

    if (spriteValue !== 0) {
      // Si un sprite est présent, affiche le numéro du sprite par-dessus
      tile.style.backgroundColor = '#ffcc00'; // Fond jaune pour les sprites
      tile.textContent = spriteValue; // Affiche l'ID du sprite
    }
  });
  // Force immediate re-render to ensure the tiles are displayed correctly
  requestAnimationFrame(() => {
    spriteGrid.classList.remove('hidden');
  });
}
      
      // Function to initialize the sprite map grid
      function createSpriteMap() {
        spriteGrid.innerHTML = ''; // Clear any existing tiles
        // Create the grid structure
        for (let y = 0; y < worldSpriteMap.length; y++) {
          for (let x = 0; x < worldSpriteMap[y].length; x++) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.setAttribute('data-x', x);
            tile.setAttribute('data-y', y);
            // Add click event for placing sprites on the map
            tile.addEventListener('click', () => {
              if (selectedTile !== null && currentTab === 'sprites') {
                placeSprite(x, y);
              }
            });
            spriteGrid.appendChild(tile);
          }
        }
        updateSpriteGrid(); // Call this to populate the initial sprites
      }
      // Place sprite at specific (x, y) coordinates on the sprite map
      // Place sprite at specific (x, y) coordinates on the sprite map
      // Place sprite at specific (x, y) coordinates on the sprite map
      function placeSprite(x, y) {
        // Check if there's a wall in the worldMap at this position
        const isWall = worldMap[y][x] === 1;
        // Prevent placing a sprite if there's a wall
        if (!isWall && selectedTile !== null) {
          // Place the selected sprite number directly into the sprite map
          worldSpriteMap[y][x] = selectedTile; // Store the number representing the sprite
          // Fill sprite properties with false/default values
          const newSprite = {
            id: selectedTile, // Just using the selectedTile value as the ID for now
            x: x,
            y: y,
            texture: false, // Placeholder false texture
            name: `Sprite ${selectedTile}`,
            isBlocking: false,
            hp: 0,
            dmg: 0,
            interaction: false
          };
          // Add this new sprite to the array of sprites (optional in case you need to track)
          sprites.push(newSprite);
          // Update the grid to show the number corresponding to the sprite
          updateSpriteGrid();
        }
      }
      // Get Tile Color
      function getTileColor(tileValue) {
        const colors = {
          0: '#fff', // white
          1: '#ccc', // gray
          2: '#00ff00', // green
          3: '#ff0000', // red
          4: '#00ff00', // green
          5: '#0000ff', // blue
          6: '#ffa500', // orange
          7: '#ff00ff', // magenta
          8: '#00ffff', // cyan
          9: '#ffa500', // orange
          10: '#a52a2a', // brown
          11: '#008000', // dark green
          12: '#800080', // purple
          13: '#ffff00' // yellow
        };
        return colors[tileValue] || '#fff';
      }
      // Handle Tile Click
      // Handle tile or sprite placement
      function onTileClick(x, y, type) {
        if (type === 'map') {
          if (selectedTile !== null) {
            worldMap[y][x] = selectedTile; // Place the selected tile in the map
            updateMapGrid(); // Re-render the map
          }
        } else if (type === 'sprites') {
          placeSprite(x, y); // Call the function to place a sprite in the sprite grid
        }
      }

      function setupPalette() {
        const palette = document.getElementById('palette');
        palette.innerHTML = ''; // Vider la palette existante
      
        if (currentTab === 'map') {
          // Titre de la palette de carte
          palette.innerHTML = `<h2>Palette de Carte</h2>`;
      
          // Ajouter les tuiles de base à la palette de carte
          basicTiles.forEach(tile => {
            addTileToPalette(tile);
          });
        } else if (currentTab === 'sprites') {
          // Titre de la palette des sprites
          palette.innerHTML = `<h2>Palette de Sprites</h2>`;
      
          // Ajouter les sprites de base à la palette des sprites
          basicSprites.forEach(sprite => {
            addSpriteToPalette(sprite);
          });
      
          // Ajouter les sprites personnalisés à la palette des sprites
          if (customSprites.length > 0) {
            const customTitle = document.createElement('h2');
            customTitle.textContent = 'Sprites Personnalisés';
            palette.appendChild(customTitle);
            customSprites.forEach(sprite => {
              addSpriteToPalette(sprite);
            });
          }
        }
      }
      
      function addTileToPalette(tile) {
        const palette = document.getElementById('palette');
        const tileButton = document.createElement('button'); // Utilisez un bouton au lieu d'un div
        tileButton.className = 'tile-item';
        tileButton.dataset.tileId = tile.id;
      
        // Affichage de base des informations de la tuile
        tileButton.innerHTML = `
          <strong>${tile.tileName}</strong><br>
          ${tile.description}
        `;
      
        // Ajouter la tuile à la palette
        palette.appendChild(tileButton);
      
        // Ajouter un événement pour sélectionner une tuile à partir de la palette
        tileButton.addEventListener('click', () => {
          selectedTile = tile.id; // Mémoriser l'ID de la tuile sélectionnée
          highlightSelectedTile(tileButton); // Appeler une fonction pour mettre en évidence la sélection
        });
      }
      
      // Fonction pour mettre en évidence la tuile sélectionnée
      function highlightSelectedTile(selectedElement) {
        const buttons = document.querySelectorAll('.palette .tile-item');
        buttons.forEach(btn => btn.classList.remove('active')); // Retirer la classe active de toutes les tuiles
        selectedElement.classList.add('active'); // Ajouter la classe active à l'élément sélectionné
      }
      

      function addSpriteToPalette(sprite) {
        const palette = document.getElementById('palette');
        const spriteButton = document.createElement('button'); // Utiliser un bouton pour les sprites
        spriteButton.className = 'sprite-item';
        spriteButton.dataset.spriteId = sprite.id;
      
        // Affichage de base des informations du sprite
        spriteButton.innerHTML = `
          <strong>${sprite.spriteName}</strong><br>
          Texture: ${sprite.spriteTexture}<br>
          HP: ${sprite.hp}, DMG: ${sprite.dmg}
        `;
      
        // Ajouter le sprite à la palette
        palette.appendChild(spriteButton);
      
        // Ajouter un événement pour sélectionner un sprite à partir de la palette
        spriteButton.addEventListener('click', () => {
          selectedSprite = sprite; // Mémoriser le sprite sélectionné
          highlightSelectedSprite(spriteButton); // Mettre en évidence la sélection
        });
      }
      
      function highlightSelectedSprite(selectedElement) {
        const buttons = document.querySelectorAll('.palette .sprite-item');
        buttons.forEach(btn => btn.classList.remove('active')); // Retirer la classe active de tous les sprites
        selectedElement.classList.add('active'); // Ajouter la classe active à l'élément sélectionné
      }
      


      // Select Tile
      function selectTile(tileId) {
        selectedTile = tileId;
        // Highlight selected tile button
        const buttons = palette.querySelectorAll('button');
        buttons.forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
      }
      // Select Sprite
      function selectSprite(spriteId) {
        selectedTile = spriteId;
        // Highlight selected sprite button
        const buttons = palette.querySelectorAll('button');
        buttons.forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
      }
      // Setup Tabs
      function setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(btn => {
          btn.addEventListener('click', (event) => {
            // Remove the active class from all buttons and add it to the clicked one
            tabButtons.forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
      
            // Hide all containers (map, sprites, teleporters, export, custom-sprite form)
            document.querySelectorAll('.map-container, .sprite-map-container, .export-area, #custom-sprite-form, #teleport-form').forEach(container => {
              container.style.display = 'none'; // Hide all containers by default
            });
      
            const selectedTab = event.target.getAttribute('data-tab');
      
            if (selectedTab === 'map') {
              document.getElementById('map-container').style.display = 'block';
              setTimeout(() => setupPalette(), 50); // Load the map palette with a slight delay
            } else if (selectedTab === 'sprites') {
              document.getElementById('sprite-map-container').style.display = 'block';
              setTimeout(() => setupPalette(), 50); // Load the sprite palette with a slight delay
              updateMapGrid(); // Mettre à jour la grille de la carte pour l'afficher en arrière-plan
              updateSpriteGrid(); // Mettre à jour la grille des sprites au premier plan
            }
             else if (selectedTab === 'custom-sprites') {
              document.getElementById('custom-sprite-form').style.display = 'block';
              setTimeout(() => setupCustomSpritePalette(), 50); // Show the custom sprites in the palette with a slight delay
            } else if (selectedTab === 'teleporters') {
              document.getElementById('teleport-form').style.display = 'block';
            } else if (selectedTab === 'export') {
              document.getElementById('export-area').style.display = 'block';
            }
            currentTab = selectedTab;
          });
        });
      }
      
      
      // Sprite Modal Functions
      function openSpriteModal(x = null, y = null, sprite = null) {
        spriteModal.style.display = 'flex';
        if (sprite) {
          // Edit existing sprite
          document.getElementById('sprite-id').value = sprite.id;
          document.getElementById('sprite-type').value = sprite.type;
          document.getElementById('sprite-name').value = sprite.name;
          document.getElementById('sprite-w').value = sprite.w;
          document.getElementById('sprite-h').value = sprite.h;
          document.getElementById('sprite-angle').value = sprite.angle;
          document.getElementById('sprite-texture').value = sprite.texture;
          document.getElementById('sprite-isBlocking').checked = sprite.isBlocking;
          document.getElementById('sprite-attackable').checked = sprite.attackable;
          document.getElementById('sprite-hp').value = sprite.hp;
          document.getElementById('sprite-dmg').value = sprite.dmg;
          document.getElementById('sprite-turn').value = sprite.turn;
          document.getElementById('sprite-interaction').value = JSON.stringify(sprite.interaction);
          document.getElementById('sprite-layer').value = sprite.layer;
          document.getElementById('sprite-animations').value = sprite.animations.join(',');
        } else {
          // Create new sprite
          document.getElementById('sprite-id').value = `sprite_${spriteIdCounter++}`;
          document.getElementById('sprite-type').value = 'PNJ';
          document.getElementById('sprite-name').value = '';
          document.getElementById('sprite-w').value = 1;
          document.getElementById('sprite-h').value = 1;
          document.getElementById('sprite-angle').value = 0;
          document.getElementById('sprite-texture').value = '';
          document.getElementById('sprite-isBlocking').checked = false;
          document.getElementById('sprite-attackable').checked = false;
          document.getElementById('sprite-hp').value = 0;
          document.getElementById('sprite-dmg').value = 0;
          document.getElementById('sprite-turn').value = 0;
          document.getElementById('sprite-interaction').value = '';
          document.getElementById('sprite-layer').value = 1;
          document.getElementById('sprite-animations').value = '';
        }
      }

      function closeSpriteModal() {
        spriteModal.style.display = 'none';
      }

      function generateUniqueSpriteId() {
        const existingIds = [...basicSprites, ...customSprites].map(sprite => sprite.id);
        let newId = existingIds.length + 1;
      
        // Vérifie que l'ID est unique, sinon incrémente jusqu'à trouver un ID libre
        while (existingIds.includes(newId)) {
          newId++;
        }
      
        return newId;
      }      

      function saveSprite() {
        const id = document.getElementById('sprite-id').value;
        const type = document.getElementById('sprite-type').value;
        const name = document.getElementById('sprite-name').value;
        const w = parseInt(document.getElementById('sprite-w').value);
        const h = parseInt(document.getElementById('sprite-h').value);
        const angle = parseInt(document.getElementById('sprite-angle').value);
        const texture = document.getElementById('sprite-texture').value;
        const isBlocking = document.getElementById('sprite-isBlocking').checked;
        const attackable = document.getElementById('sprite-attackable').checked;
        const hp = parseInt(document.getElementById('sprite-hp').value);
        const dmg = parseInt(document.getElementById('sprite-dmg').value);
        const turn = parseInt(document.getElementById('sprite-turn').value);
        let interaction = {};
        try {
          interaction = JSON.parse(document.getElementById('sprite-interaction').value);
        } catch (e) {
          alert('Format d\'interaction invalide. Veuillez utiliser un format JSON valide.');
          return;
        }
        const layer = parseInt(document.getElementById('sprite-layer').value);
        const animations = document.getElementById('sprite-animations').value.split(',').map(anim => anim.trim()).filter(anim => anim !== '');
        let sprite = sprites.find(s => s.id === id);
        if (sprite) {
          // Update existing sprite
          sprite.type = type;
          sprite.name = name;
          sprite.w = w;
          sprite.h = h;
          sprite.angle = angle;
          sprite.texture = texture;
          sprite.isBlocking = isBlocking;
          sprite.attackable = attackable;
          sprite.hp = hp;
          sprite.dmg = dmg;
          sprite.turn = turn;
          sprite.interaction = interaction;
          sprite.layer = layer;
          sprite.animations = animations;
        } else {
          // Create new sprite
          const x = parseInt(coordinatesDisplay.textContent.split(',')[0].split(':')[1].trim());
          const y = parseInt(coordinatesDisplay.textContent.split(',')[1].split(':')[1].trim());
          const newSprite = {
            id,
            type,
            name,
            x,
            y,
            w,
            h,
            angle,
            texture,
            isBlocking,
            attackable,
            hp,
            dmg,
            turn,
            interaction,
            layer,
            animations
          };
          sprites.push(newSprite);
          worldSpriteMap[y][x] = id;
        }
        updateSpriteGrid();
        closeSpriteModal();
      }
      // Array to hold custom sprites
      let customSprites = [];
      // Create custom sprite and add to the palette
      // Create custom sprite and add to the palette
      function createCustomSprite() {
        const spriteName = document.getElementById('sprite-name').value;
        const spriteId = generateUniqueSpriteId(); // Génère automatiquement un ID unique
        const spriteX = parseInt(document.getElementById('sprite-x').value);
        const spriteY = parseInt(document.getElementById('sprite-y').value);
        const spriteZ = parseInt(document.getElementById('sprite-z').value);
        const spriteW = parseInt(document.getElementById('sprite-w').value);
        const spriteH = parseInt(document.getElementById('sprite-h').value);
        const spriteAng = parseInt(document.getElementById('sprite-ang').value);
        const spriteType = parseInt(document.getElementById('sprite-type').value);
        const spriteTexture = document.getElementById('sprite-texture').value;
        const isBlocking = document.getElementById('sprite-is-blocking').checked;
        const attackable = document.getElementById('sprite-attackable').checked;
        const turn = document.getElementById('sprite-turn').checked;
        const hp = parseInt(document.getElementById('sprite-hp').value);
        const dmg = parseInt(document.getElementById('sprite-dmg').value);
        const animationProgress = parseInt(document.getElementById('sprite-animation-progress').value);
        const spriteFace = document.getElementById('sprite-face').value;
        const spriteTalk = document.getElementById('sprite-talk').value.split(',');
        const spriteSell = document.getElementById('sprite-sell').value.split(',');
      
        if (spriteName && !isNaN(spriteId)) {
          // Créer le nouveau sprite personnalisé
          const newSprite = {
            id: spriteId,
            x: spriteX,
            y: spriteY,
            z: spriteZ,
            w: spriteW,
            h: spriteH,
            ang: spriteAng,
            spriteType: spriteType,
            spriteTexture: spriteTexture,
            isBlocking: isBlocking,
            attackable: attackable,
            turn: turn,
            hp: hp,
            dmg: dmg,
            animationProgress: animationProgress,
            spriteName: spriteName,
            spriteFace: spriteFace,
            spriteTalk: spriteTalk,
            spriteSell: spriteSell
          };
      
          // Ajouter le sprite personnalisé à la liste des sprites personnalisés
          customSprites.push(newSprite);
      
          // Ajouter le nouveau sprite à la palette
          addSpriteToPalette(newSprite);
      
          // Réinitialiser le formulaire après la création
          document.getElementById('sprite-name').value = '';
          document.getElementById('sprite-x').value = '0';
          document.getElementById('sprite-y').value = '0';
          document.getElementById('sprite-z').value = '0';
          document.getElementById('sprite-w').value = '128';
          document.getElementById('sprite-h').value = '128';
          document.getElementById('sprite-ang').value = '0';
          document.getElementById('sprite-type').value = '0';
          document.getElementById('sprite-texture').value = '';
          document.getElementById('sprite-is-blocking').checked = true;
          document.getElementById('sprite-attackable').checked = false;
          document.getElementById('sprite-turn').checked = true;
          document.getElementById('sprite-hp').value = '1';
          document.getElementById('sprite-dmg').value = '1';
          document.getElementById('sprite-animation-progress').value = '0';
          document.getElementById('sprite-face').value = '';
          document.getElementById('sprite-talk').value = '';
          document.getElementById('sprite-sell').value = '';
        } else {
          alert('Veuillez saisir un nom pour le sprite.');
        }
      }

      
      // Add a new custom sprite to the palette
      function addSpriteToPalette(sprite) {
        const palette = document.getElementById('palette');
        const btn = document.createElement('button');
        btn.textContent = `${sprite.id} - ${sprite.name}`;
        btn.onclick = () => selectTile(sprite.id); // Allow selection of custom sprite
        palette.appendChild(btn);
      }
      // Setup the custom sprite palette when on the "Custom Sprites" tab
      function setupCustomSpritePalette() {
        const palette = document.getElementById('palette');
        palette.innerHTML = `
																																																					
																																																					<h2>Palette des Sprites Personnalisés</h2>`;
        // If there are custom sprites, display them in the palette
        if (customSprites.length > 0) {
          customSprites.forEach(sprite => {
            addSpriteToPalette(sprite); // Reuse the addSpriteToPalette function
          });
        } else {
          // If no custom sprites are present, display a message
          const noSpritesMessage = document.createElement('p');
          noSpritesMessage.textContent = "Aucun sprite personnalisé pour le moment.";
          palette.appendChild(noSpritesMessage);
        }
      }
      // Teleporter Functions
      function setupTeleporterSelect() {
        teleportSelect.innerHTML = ' < option value = "0" > Sélectionnez un téléporteur < /option>';
        teleporters.forEach((tp, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = tp.name || `Téléporteur ${index + 1}`;
          teleportSelect.appendChild(option);
        });
        teleportSelect.addEventListener('change', () => {
          const index = teleportSelect.value;
          if (index === '') {
            document.getElementById('teleport-details').style.display = 'none';
            return;
          }
          const tp = teleporters[index];
          document.getElementById('teleport-name').value = tp.name;
          document.getElementById('teleport-id').value = tp.id;
          document.getElementById('teleport-start-x').value = tp.startX;
          document.getElementById('teleport-start-y').value = tp.startY;
          document.getElementById('teleport-end-x').value = tp.endX;
          document.getElementById('teleport-end-y').value = tp.endY;
          document.getElementById('teleport-rotation').value = tp.rotation;
          document.getElementById('teleport-context').value = tp.context;
          document.getElementById('teleport-details').style.display = 'block';
        });
      }

      function addTeleporter() {
        const newTeleporter = {
          name: `Téléporteur ${teleporters.length + 1}`,
          id: `tp_${teleporters.length + 1}`,
          startX: -1,
          startY: -1,
          endX: -1,
          endY: -1,
          rotation: 'nord',
          context: ''
        };
        teleporters.push(newTeleporter);
        setupTeleporterSelect();
        teleportSelect.value = teleporters.length - 1;
        const event = new Event('change');
        teleportSelect.dispatchEvent(event);
      }

      function saveTeleporter() {
        const index = teleportSelect.value;
        if (index === '') return;
        const tp = teleporters[index];
        tp.name = document.getElementById('teleport-name').value;
        tp.id = document.getElementById('teleport-id').value;
        tp.startX = parseInt(document.getElementById('teleport-start-x').value);
        tp.startY = parseInt(document.getElementById('teleport-start-y').value);
        tp.endX = parseInt(document.getElementById('teleport-end-x').value);
        tp.endY = parseInt(document.getElementById('teleport-end-y').value);
        tp.rotation = document.getElementById('teleport-rotation').value;
        tp.context = document.getElementById('teleport-context').value;
        setupTeleporterSelect();
        teleportSelect.value = index;
        const event = new Event('change');
        teleportSelect.dispatchEvent(event);
        alert('Téléporteur enregistré avec succès.');
      }

      function deleteTeleporter() {
        const index = teleportSelect.value;
        if (index === '') return;
        if (confirm('Êtes-vous sûr de vouloir supprimer ce téléporteur ?')) {
          teleporters.splice(index, 1);
          setupTeleporterSelect();
          document.getElementById('teleport-details').style.display = 'none';
          alert('Téléporteur supprimé.');
        }
      }
      // Export Functions
      function exportAll() {
        const gameData = {
          worldMap,
          sprites,
          teleporters
        };
        exportOutput.value = JSON.stringify(gameData, null, 2);
        alert('Exportation réussie.');
      }

      function copyExport() {
        exportOutput.select();
        exportOutput.setSelectionRange(0, 99999);
        document.execCommand('copy');
        alert('Le JSON a été copié dans le presse-papier.');
      }
      // Save and Load Functions
      function saveToJSON() {
        const gameData = {
          worldMap,
          sprites,
          teleporters
        };
        return JSON.stringify(gameData);
      }

      function loadFromJSON(json) {
        try {
          const gameData = JSON.parse(json);
          worldMap = gameData.worldMap;
          sprites = gameData.sprites;
          teleporters = gameData.teleporters;
          worldSpriteMap = generateWorldMap(24, 24, 'x', 0);
          sprites.forEach(sprite => {
            worldSpriteMap[sprite.y][sprite.x] = sprite.id;
          });
          updateMapGrid();
          updateSpriteGrid();
          setupTeleporterSelect();
          alert('Chargement réussi.');
        } catch (e) {
          alert('Erreur lors du chargement du JSON.');
        }
      }
      // Reset Map
      function resetMap() {
        worldMap = generateWorldMap(24, 24, 1, 0);
        worldSpriteMap = generateWorldMap(24, 24, 'x', 0);
        sprites = [];
        teleporters = [];
        spriteIdCounter = 1;
        updateMapGrid();
        updateSpriteGrid();
        setupTeleporterSelect();
        setupPalette();
        alert('Carte réinitialisée.');
      }

      function confirmResetMap() {
        resetMap();
        document.getElementById('confirmationModal').style.display = 'none';
      }

      function cancelResetMap() {
        document.getElementById('confirmationModal').style.display = 'none';
      }

      function saveAllMaps() {
        // Préparer l'état complet de l'éditeur (incluant plusieurs cartes et les sprites personnalisés)
        const saveData = {
          maps: maps.map(map => ({
            ...map,
            customSprites: customSprites // Inclure les sprites personnalisés dans chaque carte
          })),
          customSprites: customSprites // Ajouter les sprites personnalisés à l'état sauvegardé
        };
        
        // Convertir l'état en une chaîne JSON avec mise en page (indentation)
        const jsonString = JSON.stringify(saveData, null, 2);
        
        // Créer un fichier téléchargeable
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "multi-map-save.json"; // Nom de fichier pour les sauvegardes multiples
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
      

function loadAllMaps(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    const loadedState = JSON.parse(e.target.result);

    // Restaurer l'état complet avec plusieurs cartes et les sprites personnalisés
    maps = loadedState.maps || [];
    customSprites = loadedState.customSprites || [];

    // Charger la première carte par défaut lors du chargement
    currentMapIndex = 0;
    loadMap(currentMapIndex);

    // Recréer la palette des sprites personnalisés après le chargement
    setupCustomSpritePalette();
    setupPalette(); // Mettre à jour la palette globale
  };

  reader.readAsText(file);
}

      // Handle Export Area Buttons
      function handleExportButtons() {
        // Already handled by exportAll and copyExport functions
      }
      // Event Listeners
      window.onclick = function(event) {
        if (event.target == spriteModal) {
          spriteModal.style.display = 'none';
        }
        if (event.target == document.getElementById('confirmationModal')) {
          document.getElementById('confirmationModal').style.display = 'none';
        }
      }

      function resetCurrentMap() {
        // Check if the current map exists in the maps array
        if (!maps[currentMapIndex]) {
          const createNew = confirm("Aucune carte n'est trouvée. Voulez-vous en créer une nouvelle ?");
          if (createNew) {
            createNewMap(); // Create a new map if none exist
          }
          return;
        }
        const mapData = maps[currentMapIndex];
        const mapSize = 24; // 24x24 matrix
        const borderValue = 1; // Value for the border
        const defaultTile = 0; // Default value for the inner tiles
        // Reset the map to a 24x24 matrix with border
        mapData.map = Array.from({
          length: mapSize
        }, (_, rowIndex) => {
          return Array.from({
            length: mapSize
          }, (_, colIndex) => {
            if (rowIndex === 0 || rowIndex === mapSize - 1 || colIndex === 0 || colIndex === mapSize - 1) {
              return borderValue;
            } else {
              return defaultTile;
            }
          });
        });
        // Reset sprites for this specific map
        mapData.sprites = [];
        // Clear teleporters
        mapData.eventA = [];
        mapData.eventB = [];
        // Optionally reset player start position
        mapData.playerStart = {
          X: 0,
          Y: 0,
          Orientation: 0,
          ceilingRender: false,
          ceilingHeight: 2,
          ceilingTexture: 1,
          floorTexture: 1
        };
        // Re-render the map, sprites, and teleporters
        loadMap(currentMapIndex);
      }
      // Initialize Editor
      window.onload = function() {
        if (maps.length === 0) {
          createNewMap(); // Automatically create a new map if none exist
        }
        initialize(); // Ensure other editor initialization happens after map creation
      };
    </script>
  </body>
</html>